---
title: "TD_1_3"
format: html
editor: visual
date: "2024-02-25"
image: "exercice.png"
categories: [TD]

---

```{r}
#| echo: true
#| eval: true
#| warning: false

library(rvest)
library(purrr)
library(stringr)

# penser à vérifer le chemin de travail 
getwd()
```

```{r}
#| echo: false
#setwd("/Users/Isabel/Desktop/Cours/R avancé/my_blog/posts/Excercices-TD")
```



# TD 1

Exercice

Pour cet exercice, nous allons télécharger un jeu de données issu de <https://data.gouv.fr> sur les infrastructures olympiques des JO 2024 à Paris.

L’objectif de cet exercice est d’utiliser uniquement des fonctions de R base. - pas de librairie tierce sauf mention contraire.

## 2. Téléchargement jeu de données depuis le site

```{r}

url <- "https://www.data.gouv.fr/fr/datasets/r/3f8ea372-3847-495d-9b93-c4a76d553166"
data_ex <- read.csv(url, sep = ";")

```

```{r}
names(data_ex)
dim(data_ex)
str(data_ex)
```

Le nombre de lignes est de 31 pour 4 colonnes nomées : geo_point, nom, sites_olympiques_paralympiques, sports

## 3 et 4 Combien y a t’il de sites olympiques et paralympiques ?

```{r}
head(data_ex)
 
table(data_ex$sites_olympiques_paralympiques )


sites_olympiques <- 0
sites_paralympique <- 0

for (site in data_ex$sites_olympiques_paralympiques) {
  if( grepl("Site olympique", site)) {
    sites_olympiques <- sites_olympiques + 1
  }
  if(grepl("Site paralympique", site)){
    sites_paralympique <- sites_paralympique + 1
  }
}

print(paste("Il y a au total", sites_olympiques, "sites olympiques et", sites_paralympique, "sites paralympiques."))

```

## 5. Quels sont les sites qui accueillent plusieurs disciplines sportives ?

```{r}

sites_multi_sport <- data_ex[sapply(strsplit(data_ex$sports, ","), length) >1, ]
print("Les sites accueillant plusieurs disciplines sportives sont :")
print(sites_multi_sport$nom)
```

## 6. Quels sont les disciplines para-olympiques accueillies dans ces sites franciliens ?

(franciliens = De l'Île-de-France)

```{r}
data_paralympique <- data_ex[grepl("Site paralympique", data_ex$sites_olympiques_paralympiques), ]

disciplines_paralympiques <- unique(unlist(strsplit(data_paralympique$sports, ",")))

print(paste("Les disciplines para-olympiques accueillies sont:", paste(disciplines_paralympiques, collapse = ", ")))


```

Concernant le code :

unlist(...) transforme cette liste en un vecteur unique, concaténant tous les éléments des différentes entrées en un seul vecteur long.

unique(...) extrait les éléments uniques de ce vecteur, supprimant les répétitions.

## 7. Quel(s) site(s) accueille(nt) le plus de disciplines différentes ?

```{r}

sapply(strsplit(data_ex$sports, ","), function(x) length(unique(x)) )

nombre_de_disciplines <- data.frame(site = data_ex$nom, 
                         nombre_disciplines = sapply(strsplit(data_ex$sports, ","), function(x) length(unique(x))))

sites_nombre_disciplines <- nombre_de_disciplines[order                                            (-nombre_de_disciplines$nombre_disciplines),]

sites_4_disciplines <- sites_nombre_disciplines[sites_nombre_disciplines$nombre_disciplines>3,]

print(paste("Les sites accueillant les plus de disciplines (4) sont :", paste(sites_4_disciplines$site, collapse = ",")))


```

## 8. Quel discipline aura lieu sur le plus grand nombre de sites ? Quels sont ces sites ?

------------------------------------------------------------------------

# TD 2

Exercice

## Question 1

Lancez la commande suivante :

```{r}
list_tables <-
  session("https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques") |>
  html_elements(".wikitable") |>
  html_table()

list_tables
```

Que s’est-il passé ? Que contient l’objet list_tables ?

Recupere l'info de wikipedia et contient une liste de tibbles, chacun représentant un tableau contenant les informations sur les médaillés olympiques.

## Question 2

Première table.

Créez un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables.

```{r}
data_medailles_sport_ete <-  list_tables[[1]]
```

La table n’est pas bien formattée.

Je supprime la première colonne, la première ligne et je modifie les noms de colonnes

```{r}
data_medailles_sport_ete <- data_medailles_sport_ete[-1, -1]

colnames(data_medailles_sport_ete) <- c("Discipline", "Annees", "Editions", "Epreuves_2020", "Or", "Argent", "Bronze", "Total", "Athletes_medailles", "Athletes_or")

str(data_medailles_sport_ete)
```

Les colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total seront converties en colonnes d’entiers.

```{r}
data_medailles_sport_ete[c("Editions", "Epreuves_2020", "Or", "Argent", "Bronze", "Total")] <- lapply(data_medailles_sport_ete[c("Editions", "Epreuves_2020", "Or", "Argent", "Bronze", "Total")], as.integer)

str(data_medailles_sport_ete)
```

## Question 3

Quelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?

```{r}

top3_disciplines <- data_medailles_sport_ete[order(data_medailles_sport_ete$Total, decreasing = TRUE), ][1:3,]

cat("Les 3 disciplines avec le plus de médailles sont :", paste(top3_disciplines$Discipline, collapse = ", "), "\n")

```

## Question 4

Quelles sont les disciplines avec le moins d’épreuves en 2020 ?

```{r}

disc_moins_epreuves_2020 <- data_medailles_sport_ete[(data_medailles_sport_ete$Epreuves_2020 == (min(data_medailles_sport_ete$Epreuves_2020))),] 
# utilisation du min et == pour trouver les epreuves avec le moins d'épreuves

cat("Les disciplines avec le moins d'éprevues en 2020 sont:", paste(disc_moins_epreuves_2020$Discipline, collapse = ","))

```

## Question 5

La colonne Editions nous renseigne sur le nombre total d’apparence des disciplines aux JO d’été. Nous souhaitons vérifier ce calcul en implémentant notre propre fonction calcul_nb_editions_int. Dans un premier temps, la fonction calcul_nb_editions prendra en entrée un paramètre depuis, de type entier, qui représente depuis quelle année la discipline est au programme.

```{r}
# Premier partie, fonction calcul de nombre d'editions 
calcul_nb_editions <- function(depuis){
  # Calcul de l'année en cours pour connaitre le nombre d'année au total
  annee_actuelle <- as.integer(format(Sys.Date(), "%Y"))
  annees_editions <- seq(depuis, annee_actuelle, 4)
  nb_edtions <- length(annees_editions)
  return(nb_edtions)
}
calcul_nb_editions(1896)

# Sys.Date() est une fonction en R qui retourne la date courante.
#Formate cette date pour extraire l'année en cours sous forme de chaîne de caractères avec format(…, "%Y") et as.integer convertit cette chaîne en un entier avec as.integer()

```

La deuxieme partie, consiste à verifier la colonne Editions, à l'aide d'une fonction appelée \<calcul_nb_editions_int\> .

```{r}
str(data_medailles_sport_ete$Annees)

```

Pour vérifier la colonne Éditions, il est nécessaire de récupérer les informations relatives aux années de participation aux Jeux Olympiques, que ce soit par année individuelle, par plage d'années, ou en continu depuis une année donnée. La colonne des années est définie comme une chaîne de caractères; Il faut donc créer une fonction qui extraira toutes les années et les comptabilisera.

```{r}

calcul_nb_editions_str <- function(annee_texte){
  annee_actuelle <- as.integer(format(Sys.Date(), "%Y"))
  annees <- unlist(str_extract_all(annee_texte, "\\b\\d{4}\\b")) # Extraire toutes les années individuelles
   depuis_annees <- as.integer(unlist(str_extract_all(annee_texte, regex("(?<=depuis )\\d{4}", ignore_case = TRUE)))) # Extraire les années de départ pour "depuis / Depuis "
  
   # Traiter les plages d'années
  plages <- str_extract_all(annee_texte, "\\d{4}–\\d{4}") # Extraire les plages d'années
  plages <- unlist(plages)
  for (plage in plages) {
    annees_debut_fin <- as.integer(unlist(str_extract_all(plage, "\\d{4}")))
    annees <- c(annees, seq(annees_debut_fin[1], annees_debut_fin[2], by = 4))
  }
  # Ajouter les éditions depuis les années spécifiques jusqu'à l'année actuelle
  for (depuis_annee in depuis_annees) {
    annees_depuis <- seq(depuis_annee, annee_actuelle, by = 4)
    annees <- c(annees, annees_depuis)
  }
   # Calculer le nombre d'éditions uniques
  nb_editions <- length(unique(as.integer(annees)))
  
  return(nb_editions)
}


comparatif <- data.frame(
  Edtions = data_medailles_sport_ete$Editions, 
  Editions_a_2024 = sapply(data_medailles_sport_ete$Annees, calcul_nb_editions_str))



```

::: callout-tip
## regex(..., ignore_case = TRUE)

Est utilisé pour créer une expression régulière avec l'option ignore_case = TRUE, rendant la recherche insensible à la casse.
:::

## Question 6

Dans certains cas, les disciplines ont été au programme de façon discontinue. Proposez une nouvelle fonction calcul_nb_editions_str qui prendra cette fois-ci en entrée des chaînes de caractères. Par exemple, l’appel suivant: calcul_nb_editions_str("1896, 1904, depuis 1920")

::: callout-note
La fonction `calcul_nb_editions_str` a déjà était conçue pour extraire des années individuelles, traiter des plages d'années, et compter les éditions depuis une certaine année jusqu'à l'année actuelle dans la question 6.
:::

Cepandant si les années sont presentés comme une liste ou un vecteur (incluant des valeurs individuelles ), il faut une function tel que :

```{r}

calcul_nb_editions.integer <- function(annees_participation) {
  nb_participations <- length(unique(annees_participation))
  return(nb_participations)
}

calcul_nb_editions.integer(1900)

```

## Question 7

Définissez une fonction générique calcul_nb_editions et deux implémentations calcul_nb_editions.integer et ‘calcul_nb_editions.character. Quels résultats donnent les appels : calcul_nb_editions(2000) calcul_nb_editions("1904–1924, depuis 1948")

```{r}

# Définition de la fonction génerique
calcul_nb_editions <- function(x) {
  UseMethod("calcul_nb_editions")
}

```

Pour les Entiers

```{r}
calcul_nb_editions.integer <- function(x) {
  nb_participations <- length(unique(x))
  return(nb_participations)
}



```

Pour les Chaînes de Caractères

```{r}
calcul_nb_editions.character <- function(x) {
  annee_actuelle <- as.integer(format(Sys.Date(), "%Y"))
  annees <- unlist(str_extract_all(x, "\\b\\d{4}\\b")) # Extraire toutes les années individuelles
  depuis_annees <- as.integer(unlist(str_extract_all(x, regex("(?<=depuis )\\d{4}", ignore_case = TRUE)))) # Extraire les années de départ pour "depuis / Depuis"
  
  # Traiter les plages d'années
  plages <- str_extract_all(x, "\\d{4}–\\d{4}") # Extraire les plages d'années
  plages <- unlist(plages)
  for (plage in plages) {
    annees_debut_fin <- as.integer(unlist(str_extract_all(plage, "\\d{4}")))
    annees <- c(annees, seq(annees_debut_fin[1], annees_debut_fin[2], by = 4))
  }
  # Ajouter les éditions depuis les années spécifiques jusqu'à l'année actuelle
  for (depuis_annee in depuis_annees) {
    annees_depuis <- seq(depuis_annee, annee_actuelle, by = 4)
    annees <- c(annees, annees_depuis)
  }
  # Calculer le nombre d'éditions uniques
  nb_editions <- length(unique(as.integer(annees)))
  
  return(nb_editions)
}



```

```{r}
#| eval:  false
#| warning: false

calcul_nb_editions(2000)
calcul_nb_editions("1904–1924, depuis 1948")
```

Error in `UseMethod()`: ! no applicable method for 'calcul_nb_editions' applied to an object of class "c('double', 'numeric')" Backtrace: 1. global calcul_nb_editions(2000)

R traite les nombres sans décimales non explicitement définis comme entiers (integer) en tant que nombres à virgule flottante (double), même s'ils sont sans partie décimale.

Il faut donc définir une méthode calcul_nb_editions.double qui traite ou redirige simplement vers calcul_nb_editions.integer, en tenant compte que les nombres seront traités comme des double par défaut :

```{r}
calcul_nb_editions.double <- function(x) {
  # Appeler directement calcul_nb_editions.integer 
calcul_nb_editions.integer(as.integer(x))}

```

```{r}
calcul_nb_editions(2000)
calcul_nb_editions("1904–1924, depuis 1948")
```

## Question 8

En Athlétisme, le Finlandais Paavo Nurmi détient le record de médailles avec 12 médailles obtenues lors des JO d’hiver.

Implémentez une fonction \< calcul_medailles_individuelles\> qui détermine le nombre de médaille maximal a été obtenu par un athlète lors d’olympiades. Note : s’il y a plusieurs athlètes à égalité, alors la cellule comporte plusieurs éléments, et une manipulation de la chaîne de caractères est nécessaire.

-   Les jeux olympiques d'hiver se trouvent dans la list_tables, 2eme

```{r}
data_medailles_sport_hiver <- list_tables[[2]]
data_medailles_sport_hiver <- data_medailles_sport_hiver[-1,-1]
data_medailles_sport_hiver$Discipline
```

La discipline Athétisme fait partie des jeux olympiques d'été et non d'hiver, alors je retourne au df été

La colonne N° 9 designe les **Athlète(s) avec le plus de médailles (Or-Argent-Bronze)**

# TERMINER PLUS TARD

```{r}



calcul_medailles_individuelles <- function(athletes_medailles) {
 
   # Étape 1: Extraire les nombres de médailles pour chaque athlète
  patterns_medailles <- str_extract_all(athletes_medailles, "\\((\\d+)-(\\d+)-(\\d+)\\)")
  medailles_liste <- lapply(patterns_medailles[[1]], function(x) {
    nums <- as.numeric(unlist(str_split(x, "-")))
    sum(nums)
  })
  
  # Étape 2: Calculer le total de médailles pour chaque athlète
  total_medailles <- unlist(medailles_liste)
  
  # Étape 3: Déterminer le maximum de médailles
  max_medailles <- max(total_medailles)
  
  # Identifier les athlètes ayant le nombre maximal de médailles
  indices_max <- which(total_medailles == max_medailles)
  
  # Extraire les noms des athlètes ayant le nombre maximal de médailles
  noms_athletes_max <- str_extract_all(athletes_medailles, "[^\\(]+")[[1]][indices_max]
  noms_athletes_max <- str_trim(noms_athletes_max) # Nettoyer les espaces
  
  return(noms_athletes_max)
}


```

```{r}

```

# TD 3

Pour ce td l'installation de plusieurs librairies a été necessaire, "stringr", "lubridate", "arrow", "dplyr", "tidyr", "jsonlite", "RSQLite".

Les données associés au TP3 sont décompressés dans un dossier appelé \<data\>

```{r}
#| warning: false
#| echo: false


library(stringr)
library(lubridate)
library(arrow)
library(dplyr)
library(tidyr)
library(jsonlite)
library(RSQLite)
```

## Question 1

Listez les fichiers présents dans le dossier data. Quelles sont les extensions des différents fichiers ?

```{r}
list.files(path = "data/")

```

Les extensions des différents fichiers dans le dossier data sont : sqlite, json et parquet

## Question 2

Lisez le fichier .parquet en utilisant la librairie arrow. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?

```{r}
tokyo_athletes <- read_parquet(file = "data/tokyo_athletes.parquet")
dim(tokyo_athletes)
names(tokyo_athletes)
str(tokyo_athletes)
```
```{r}

```


Le fichier \< tokyo_athletes.parquet \> a 3 variables de type chr : "Name" "NOC" "Discipline" et 11085 observations

## Question 3

Lisez le fichier .json en utilisant la librairie jsonlite. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?

```{r}
olympics_athletes <- fromJSON("data/olympics_athletes.json" )
dim(olympics_athletes)
names(olympics_athletes)
```

Le fichier \< olympics_athletes.json \> a 13 variables et 269731 observations.

Les colonnes sont : "ID" "Name" "Sex" "Age" "Height" "Weight" "Team" "NOC" "Games" "City" "Sport" "Event" "Medal"

## Question 4

Importez la librairie RSQLite, et ouvrez une connexion à la base de données sqlite en utilisant la fonction dbConnect. Le driver à utiliser sera SQLite(). Quelles sont les tables présentes dans la table ? Vous pourrez utiliser la fonction dbListTables.

```{r}
con <- dbConnect(RSQLite::SQLite(), dbname = "data/data.sqlite")
tables <- dbListTables(con)
print(tables)

```

Les tables presentes dans la table sont : "tokyo_medals" "tokyo_teams"

## Question 5

Créez deux nouvelles tables dans la base de données à l’aide de la fonction dbWriteTable. Les tables s’appeleront respectivement olympics_athletes et tokyo_athletes pour les fichiers olympics_athletes.json et tokyo_athletes.parquet.

```{r}
dbWriteTable(con, "olympics_athletes", olympics_athletes,  overwrite = TRUE ) 
dbWriteTable(con, "tokyo_athletes",tokyo_athletes,  overwrite = TRUE )

dbListTables(con)
```

## Question 6

Inspectez la table olympics_athletes en utilisant la fonction dbListFields. Quelles sont les colonnes de la table ?

Les colonnes sont :

```{r}
dbListFields(con, "olympics_athletes")
```

## Question 7

Importez cette table depuis la base de données en utilisant la fonction dbReadTable. Convertissez la table en tibble en utilisant la fonction as_tibble.

```{r}
olympics_athletes <- dbReadTable(con, "olympics_athletes") 
  olympics_athletes <- as_tibble(olympics_athletes)
class(olympics_athletes)
```

## Question 8

Convertissez la colonne Sex en variable catégorielle avec la fonction mutate.

```{r}
olympics_athletes <- olympics_athletes |>
  mutate(Sex = as.factor(Sex))

str(olympics_athletes)
```

## Question 9

Créez deux colonnes à partir de la colonne Games. La première colonne Year sera une colonne de type integer contenant l’année des jeux. La deuxième colonne isSummer sera une colonne booléenne qui indiquera si les jeux sont des jeux d’été ou d’hiver. Vous pourrez utiliser la fonction separate_wider_delim de tidyr notamment.

```{r}

olympics_athletes <- olympics_athletes |>
  separate(Games, into = c("Year", "isSummer"), sep = " ") |>
  mutate(
    Year = as.integer(Year),
    isSummer = isSummer == "Summer"
  )

```

## Question 10

10\. Calculez la moyenne d’age des athletes pour chacune des éditions des JO d’été. Quelle édition a compté les athlètes les plus jeunes ? Les plus vieux ?

```{r}

resultat <- olympics_athletes |>
  filter(isSummer==TRUE)|>
   group_by(Year)|>
   summarise(age_moyenne = mean(Age, na.rm = TRUE)) |>
  mutate(
    plus_jeunes = age_moyenne== min(age_moyenne),
    plus_vieux = age_moyenne == max(age_moyenne)
  ) |>
  filter(plus_jeunes | plus_vieux)

resultat
```

## Question 11

Quelle est la discipline des JO d’été dont la taille des athlètes féminines est la plus grande ? Quelle a été cette discipline au cours de chacune des éditions ? Calculez le nombre de fois où chaque discipline a été la discipline avec les plus grandes athlètes.

```{r}
femmes_taille_sport <- olympics_athletes |>
  filter(Sex == "F", isSummer == TRUE)|>
  group_by(Sport) |>
  summarise(taille_moyenne = mean(Height, na.rm = TRUE)) |>
  arrange(desc(taille_moyenne))|>
  slice(1)

femmes_taille_sport
```

```{r}
discipline_plus_grandes_par_edition <- olympics_athletes |>
  filter(Sex == "F", isSummer == TRUE) |>
  group_by(Year, Sport) |>
  summarise(taille_moyenne = mean(Height, na.rm = TRUE), .groups = "drop") |>
  # Filtrer les lignes où la taille moyenne n'est pas NaN
  filter(!is.na(taille_moyenne)) |>
  group_by(Year) |>
  slice_max(order_by = taille_moyenne, n = 1) |>
  ungroup()

discipline_plus_grandes_par_edition
```

# -----------------------------------
