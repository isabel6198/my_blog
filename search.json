[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "À Propos",
    "section": "",
    "text": "Ce premier blog est le résultat du cours de R avancé donné dans le cadre du master 1er Année ECAP, du IAE de Nantes."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Package olympicsWeather",
    "section": "",
    "text": "Le package olympicsWeather offre une solution simple et interactive pour accéder aux prévisions météorologiques des sites olympiques. Utilisant des graphiques interactifs, il permet aux utilisateurs d’explorer en profondeur les données météorologiques.\n© Illustration AdobeStock"
  },
  {
    "objectID": "posts/post-with-code/index.html#caractéristiques",
    "href": "posts/post-with-code/index.html#caractéristiques",
    "title": "Package olympicsWeather",
    "section": "Caractéristiques",
    "text": "Caractéristiques\n\nGraphiques interactifs : Grâce à plotly, le package produit des visualisations interactives des données météorologiques, améliorant ainsi l’expérience utilisateur par une exploration dynamique des prévisions.\nFacilité d’utilisation : Les prévisions sont accessibles via des coordonnées GPS ou des noms de lieux, facilitant l’accès aux données météorologiques sans expertise technique spécifique.\nIntégration de packages R : olympicsWeather s’appuie sur des packages tels que httr pour les requêtes web, jsonlite pour le traitement JSON, et tibble pour la manipulation de données, optimisant ainsi le processus d’analyse."
  },
  {
    "objectID": "posts/post-with-code/index.html#installation",
    "href": "posts/post-with-code/index.html#installation",
    "title": "Package olympicsWeather",
    "section": "Installation",
    "text": "Installation\nLe package olympicsWeather est disponible sur GitHub et peut être installé en utilisant le package remotes. Si vous n’avez pas encore installé remotes, commencez par le faire avec la commande install.packages(\"remotes\").\nEnsuite, installez olympicsWeather en utilisant la commande suivante :\n\nremotes::install_github(\"isabel6198/olympicsWeather\")"
  },
  {
    "objectID": "posts/post-with-code/index.html#fonctions",
    "href": "posts/post-with-code/index.html#fonctions",
    "title": "Package olympicsWeather",
    "section": "Fonctions",
    "text": "Fonctions\nLes fonctions qui sont incluses dans le package sont :\n\nperform_request: Envoie une requête à l’API Open-Meteo avec des coordonnées GPS et retourne les données météorologiques horaires sous forme de tibble.\nunnest_data: Transforme les données météorologiques brutes en un tibble structuré, extrayant des informations telles que la date, l’heure, et les températures.\nget_forecast: Fonction générique qui, selon le type d’entrée (adresse ou coordonnées GPS), renvoie des prévisions météorologiques sous forme de tibble.\naddress_to_gps et get_gps_coordinate: Convertissent une adresse textuelle en coordonnées GPS à l’aide du service de géocodage OpenStreetMap.\nget_forecast.numeric et get_forecast.character: Spécialisent get_forecast pour traiter respectivement des coordonnées GPS numériques et des adresses textuelles, renvoyant les prévisions météorologiques pour l’emplacement spécifié.\nvisualiser_temperatures: Crée un graphique interactif avec plotly à partir d’un tibble météorologique, affichant la température et la température ressentie au fil du temps.\n\nChaque fonction est conçue pour simplifier l’accès et la manipulation des données météorologiques, depuis la récupération des informations depuis une API externe jusqu’à la visualisation interactive des prévisions."
  },
  {
    "objectID": "posts/post-with-code/index.html#exemples",
    "href": "posts/post-with-code/index.html#exemples",
    "title": "Package olympicsWeather",
    "section": "Exemples",
    "text": "Exemples\n\nSite: le stade de France\n\n# librairie \nlibrary(olympicsWeather)\n\n\n# Obtenir les prévisions météorologiques à partir d'un lieu exacte\nmeteo &lt;- get_forecast(\"Stade de France, Saint-Denis, France\")\nmeteo\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie\n   &lt;dttm&gt;                            &lt;dbl&gt;                 &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 4.7                   2.6\n 2 2024-03-07 01:00:00                 4.1                   1.7\n 3 2024-03-07 02:00:00                 3.7                   1.3\n 4 2024-03-07 03:00:00                 3                     0.6\n 5 2024-03-07 04:00:00                 2.8                   0.3\n 6 2024-03-07 05:00:00                 2.6                   0  \n 7 2024-03-07 06:00:00                 2.5                  -0.1\n 8 2024-03-07 07:00:00                 2.7                   0.2\n 9 2024-03-07 08:00:00                 4                     1.6\n10 2024-03-07 09:00:00                 5.9                   3.3\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation_mm &lt;dbl&gt;\n\n# Visualer les données\ngraphique &lt;- visualiser_temperatures(meteo)\ngraphique\n\n\n\n\n\n\n\nCoordonnées GPS\n\n# Obtenir les prévisions météorologiques à partir de Coordonnées GPS \ngps &lt;- c( 43.276703, 5.334791)\n\n# Obtenir les prévisions météorologiques\nmeteo &lt;- get_forecast(gps)\nmeteo\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie\n   &lt;dttm&gt;                            &lt;dbl&gt;                 &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 8.9                   3.8\n 2 2024-03-07 01:00:00                 8.5                   3.7\n 3 2024-03-07 02:00:00                 7.8                   3.7\n 4 2024-03-07 03:00:00                 6.6                   2.7\n 5 2024-03-07 04:00:00                 7.1                   3.2\n 6 2024-03-07 05:00:00                 6.7                   3.3\n 7 2024-03-07 06:00:00                 7.3                   3.6\n 8 2024-03-07 07:00:00                 7.7                   4.8\n 9 2024-03-07 08:00:00                 8.4                   6.1\n10 2024-03-07 09:00:00                 9.3                   7.2\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation_mm &lt;dbl&gt;\n\n# Visualer les données\ngraphique &lt;- visualiser_temperatures(meteo)\ngraphique\n\n\n\n\n\n\n\nTahiti\n\n# Obtenir les prévisions météorologiques \nmeteo &lt;- get_forecast(\"Tahiti\")\n# Visualer les données\ngraphique &lt;- visualiser_temperatures(meteo)\ngraphique"
  },
  {
    "objectID": "posts/Excercices-TD/Questions.html",
    "href": "posts/Excercices-TD/Questions.html",
    "title": "Questions",
    "section": "",
    "text": "Les informations relatives à l’utilisation du package olympicsWeather sont disponibles dans le post intitulé “post-with-code”. Dans cette section, nous aborderons exclusivement les questions relatives à la création et à l’installation du package."
  },
  {
    "objectID": "posts/Excercices-TD/Questions.html#créer-son-premier-package-olympicsweather",
    "href": "posts/Excercices-TD/Questions.html#créer-son-premier-package-olympicsweather",
    "title": "Questions",
    "section": "1. Créer son premier package: olympicsWeather",
    "text": "1. Créer son premier package: olympicsWeather\nPour débuter la création du package olympicsWeather, il est nécessaire d’installer certains packages utiles au développement de packages R. Les packages devtools, httr2 et jsonlite sont essentiels pour la manipulation de données en ligne et la structuration du package.\nCréation d’un nouveau projet de package\nAprès l’installation de ces packages, la prochaine étape consiste à créer un nouveau projet de package. La fonction create_package() est utilisé pour initialiser la structure de base du package. Vous pouvez spécifier le chemin où le package doit être créé, comme dans l’exemple ci-dessous :\ncreate_package(path = “/Users/Isabel/Desktop/Cours/Ravancé/olympicsWeather”)"
  },
  {
    "objectID": "posts/Excercices-TD/Questions.html#question-pourquoi-nest-il-pas-nécessaire-dinstaller-explicitement-usethis",
    "href": "posts/Excercices-TD/Questions.html#question-pourquoi-nest-il-pas-nécessaire-dinstaller-explicitement-usethis",
    "title": "Questions",
    "section": "2. Question : Pourquoi n’est-il pas nécessaire d’installer explicitement usethis ?",
    "text": "2. Question : Pourquoi n’est-il pas nécessaire d’installer explicitement usethis ?\nIl n’est pas nécessaire d’installer explicitement usethis car devtools est déjà installé.Devtools dépend de usethis. Il utilise plusieurs fonctions de usethis pour faciliterle développement de packages en R, usethis est donc automatiquement installé comme une dépendance.”"
  },
  {
    "objectID": "posts/Excercices-TD/Questions.html#création-dun-nouveau-script-appelé-get_weather_forecast-avec-use_r-de-la-librairie-usethis-qui-permet-dajouter-facilement-un-script-r-au-projet-de-package",
    "href": "posts/Excercices-TD/Questions.html#création-dun-nouveau-script-appelé-get_weather_forecast-avec-use_r-de-la-librairie-usethis-qui-permet-dajouter-facilement-un-script-r-au-projet-de-package",
    "title": "Questions",
    "section": "3. Création d’un nouveau script appelé ‘get_weather_forecast’ avec use_r de la librairie usethis qui permet d’ajouter facilement un script R au projet de package:",
    "text": "3. Création d’un nouveau script appelé ‘get_weather_forecast’ avec use_r de la librairie usethis qui permet d’ajouter facilement un script R au projet de package:\nusethis::use_r(“get_weather_forecast”)\nlibrairies necessaires: library(httr2) et (tibble)"
  },
  {
    "objectID": "posts/Excercices-TD/Questions.html#décrivez-le-résultat.-quavons-nous-obtenu-suite-à-notre-requête-quels-paramètres-souhaitons-nous-changer-si-nous-voulons-pouvoir-récupérer-les-prévisions-météo-pour-tous-les-sites-des-jos",
    "href": "posts/Excercices-TD/Questions.html#décrivez-le-résultat.-quavons-nous-obtenu-suite-à-notre-requête-quels-paramètres-souhaitons-nous-changer-si-nous-voulons-pouvoir-récupérer-les-prévisions-météo-pour-tous-les-sites-des-jos",
    "title": "Questions",
    "section": "5. Décrivez le résultat. Qu’avons nous obtenu suite à notre requête ? Quels paramètres souhaitons nous changer si nous voulons pouvoir récupérer les prévisions météo pour tous les sites des JOs",
    "text": "5. Décrivez le résultat. Qu’avons nous obtenu suite à notre requête ? Quels paramètres souhaitons nous changer si nous voulons pouvoir récupérer les prévisions météo pour tous les sites des JOs\ntest &lt;- perform_request(latitude =48.85, longitude = 2.35 )\nLe (tibble) contient des informations générales sur la requête météorologique et le lieu des prévisions, incluant la latitude, la longitude, le temps de génération, le décalage UTC, le fuseau horaire, entre autres. Il est composé de 5 lignes et 9 colonnes.\nLa colonne hourly est elle-même une liste qui englobe des données telles que l’heure (time), la température à 2 mètres (temperature_2m), la température ressentie (apparent_temperature), la probabilité de précipitations (precipitation_probability), et les précipitations (precipitation). Ces éléments peuvent aussi être des listes. Par exemple, pour extraire des informations structurées, on peut utiliser :\n\nstr(test$hourly[2][[1]], 1)\nunlist(test$hourly[2][[1]])\n\nCela permet de récupérer le deuxième élément de la colonne hourly, qui est encore une liste. Si nous souhaitons obtenir des prévisions pour tous les sites des Jeux Olympiques, des ajustements sont nécessaires concernant les coordonnées de longitude et de latitude. De plus, il est impératif de récupérer les données météorologiques dans une structure qui facilitera la manipulation ultérieure."
  },
  {
    "objectID": "posts/Excercices-TD/Questions.html#question-7-et-8",
    "href": "posts/Excercices-TD/Questions.html#question-7-et-8",
    "title": "Questions",
    "section": "Question 7 et 8",
    "text": "Question 7 et 8\nPremier option : accès indexé aux différents types de données météorologiques\n\nunnest_data &lt;- function(test){\ntibble(date_heure = as.POSIXct(unlist(test$hourly[1][[1]]), format = '%Y-%m-%dT%H:%M', tz = 'UTC'),\n       temperature_celsius = unlist(test$hourly[2][[1]]),\n       temperature_ressenti = unlist(test$hourly[3][[1]]),\n       porcentage = unlist(test$hourly[4][[1]]),\n       precipitation = unlist(test$hourly[5][[1]]))\n}\nperform_request(lat = 47.21725, long = -1.55336) |&gt; unnest_data() -&gt; y\nnames(y)\n\nDeuxime option :\nLes données peuvent être directement extraites par leur nom :)\n\nunnest_data &lt;- function(meteo_data) {\n  # Extraction des données horaires et conversion en tibble\n  meteo_tibble &lt;- tibble(\n    date_heure = as.POSIXct(unlist(meteo_data$hourly$time), format = \"%Y-%m-%dT%H:%M\", tz = \"UTC\"),  #POSIXct avec le fuseau horaire UTC pour assurer que les heures sont correctement interprétées\n    temperature_celsius = unlist(meteo_data$hourly$temperature_2m),\n    temperature_ressentie = unlist(meteo_data$hourly$apparent_temperature),\n    precipitation_proba = unlist(meteo_data$hourly$precipitation_probability),\n    precipitation_mm = unlist(meteo_data$hourly$precipitation)\n  )\n  return(meteo_tibble)\n}\n\nL’utilisation de unlist est nécessaire pour aplatir ces listes en vecteurs, rendant possible leur manipulation et conversion.Exemple avec la conversion directe en POSIXct avec as.POSIXct échoue, car as.POSIXct attend un vecteur et non uneliste\n\nFonction get_forecast\nLe script concernant le package olympicsWeather, est diponible sur mon git https://github.com/isabel6198/olympicsWeather\nVoici quelques explications :\nNous commençons par convertir une adresse en coordonnées GPS grâce à la fonction address_to_gps. Cette étape utilise le package tidygeocoder pour obtenir latitude et longitude d’une adresse textuelle en interrogeant des services de géocodage comme OpenStreetMap. Le résultat est un vecteur numérique avec la latitude et la longitude.\nEnsuite, avec get_gps_coordinate, on transforme une adresse en coordonnées GPS, agissant comme une interface utilisateur pour address_to_gps et rendant le processus plus accessible.\nLa troisième étape est la fonction get_forecast, qui permet récupérer des prévisions météorologiques. Cette fonction générique gère différents types d’entrées, que ce soit une adresse ou des coordonnées GPS, en utilisant UseMethod pour orienter vers la méthode appropriée.\nPour les coordonnées GPS, get_forecast.numeric prend le relai. Elle assure que l’entrée est un vecteur numérique de deux éléments, effectue une requête API météo avec ces coordonnées et structure la réponse obtenue en un tibble.\nEnfin, pour une adresse, get_forecast.character permet d’obtenir les prévisions météorologiques en partant d’un texte. Elle vérifie d’abord que l’entrée est bien une chaîne de caractères, la convertit en coordonnées GPS, puis fait appel à get_forecast.numeric pour récupérer les prévisions. Le résultat est un tibble contenant les informations météorologiques pour l’adresse spécifiée.\nLa documentation a été faite en utilisant les balises Roxygen et la description : \n\n\nTest\nDans la partie test un jeu de données est crée pour tester la fonction, avec la meme structure que celle recu par perfom_request.\n\n\nGraphique\nPour fournir une sortie visuelle aux utilisateurs, j’ai développé une fonction dans le package qui génère un graphique interactif mettant en évidence les températures et les températures ressenties au fil du temps. L’utilisation de ggplot2 combinée à plotly permet d’obtenir des visualisations à la fois esthétiques et fonctionnelles, offrant aux utilisateurs la possibilité d’explorer les données de manière dynamique.\nLa fonction visualiser_temperature prend comme paremetre weather_forecast : Un Tibble ou un dataframe contenant les prévisions météorologiques à représenter graphiquement. Les données doivent inclure des colonnes spécifiques : date_heure pour les dates et heures des prévisions, temperature_celsius pour les températures mesurées en degrés Celsius, et temperature_ressentie pour les températures ressenties, également en degrés Celsius."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html",
    "href": "posts/Excercices-TD/semaine_3.html",
    "title": "Semaine 3",
    "section": "",
    "text": "# TD 3 \nlibrary(lubridate)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(jsonlite)\nlibrary(RSQLite)\n\n\n# penser à vérifer le chemin de travail et à le corriger si necessaire \ngetwd()\n\n[1] \"/Users/Isabel/Desktop/Cours/R avancé/my_blog/posts/Excercices-TD\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#questions-n",
    "href": "posts/Excercices-TD/semaine_3.html#questions-n",
    "title": "Semaine 3",
    "section": "Questions N°",
    "text": "Questions N°\nPour ce td l’installation de plusieurs librairies a été necessaire, “stringr”, “lubridate”, “arrow”, “dplyr”, “tidyr”, “jsonlite”, “RSQLite”.\nLes données associés au TP3 sont décompressés dans un dossier appelé &lt;data&gt;"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#listez-les-fichiers-présents-dans-le-dossier-data.-quelles-sont-les-extensions-des-différents-fichiers",
    "href": "posts/Excercices-TD/semaine_3.html#listez-les-fichiers-présents-dans-le-dossier-data.-quelles-sont-les-extensions-des-différents-fichiers",
    "title": "Semaine 3",
    "section": "1. Listez les fichiers présents dans le dossier data. Quelles sont les extensions des différents fichiers ?",
    "text": "1. Listez les fichiers présents dans le dossier data. Quelles sont les extensions des différents fichiers ?\n\nlist.files(path = \"data/\")\n\n[1] \"data.sqlite\"                                                 \n[2] \"olympics_athletes.json\"                                      \n[3] \"paris-2024-sites-olympiques-et-paralympiques-franciliens.csv\"\n[4] \"tokyo_athletes.parquet\"                                      \n\n\nLes extensions des différents fichiers dans le dossier data sont : sqlite, json et parquet"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#lisez-le-fichier-.parquet-en-utilisant-la-librairie-arrow.-quelles-sont-les-dimensions-de-la-table-quelles-sont-les-colonnes-présentes",
    "href": "posts/Excercices-TD/semaine_3.html#lisez-le-fichier-.parquet-en-utilisant-la-librairie-arrow.-quelles-sont-les-dimensions-de-la-table-quelles-sont-les-colonnes-présentes",
    "title": "Semaine 3",
    "section": "2. Lisez le fichier .parquet en utilisant la librairie arrow. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?",
    "text": "2. Lisez le fichier .parquet en utilisant la librairie arrow. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\ntokyo_athletes &lt;- read_parquet(file = \"data/tokyo_athletes.parquet\")\ndim(tokyo_athletes)\n\n[1] 11085     3\n\nnames(tokyo_athletes)\n\n[1] \"Name\"       \"NOC\"        \"Discipline\"\n\nstr(tokyo_athletes)\n\ntibble [11,085 × 3] (S3: tbl_df/tbl/data.frame)\n $ Name      : chr [1:11085] \"AALERUD Katrine\" \"ABAD Nestor\" \"ABAGNALE Giovanni\" \"ABALDE Alberto\" ...\n $ NOC       : chr [1:11085] \"Norway\" \"Spain\" \"Italy\" \"Spain\" ...\n $ Discipline: chr [1:11085] \"Cycling Road\" \"Artistic Gymnastics\" \"Rowing\" \"Basketball\" ...\n\n\nLe fichier &lt; tokyo_athletes.parquet &gt; a 3 variables de type chr : “Name” “NOC” “Discipline” et 11085 observations"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#lisez-le-fichier-.json-en-utilisant-la-librairie-jsonlite.-quelles-sont-les-dimensions-de-la-table-quelles-sont-les-colonnes-présentes",
    "href": "posts/Excercices-TD/semaine_3.html#lisez-le-fichier-.json-en-utilisant-la-librairie-jsonlite.-quelles-sont-les-dimensions-de-la-table-quelles-sont-les-colonnes-présentes",
    "title": "Semaine 3",
    "section": "3. Lisez le fichier .json en utilisant la librairie jsonlite. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?",
    "text": "3. Lisez le fichier .json en utilisant la librairie jsonlite. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\nolympics_athletes &lt;- fromJSON(\"data/olympics_athletes.json\" )\ndim(olympics_athletes)\n\n[1] 269731     13\n\nnames(olympics_athletes)\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\nLe fichier &lt; olympics_athletes.json &gt; a 13 variables et 269731 observations.\nLes colonnes sont : “ID” “Name” “Sex” “Age” “Height” “Weight” “Team” “NOC” “Games” “City” “Sport” “Event” “Medal”"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#importez-la-librairie-rsqlite-et-ouvrez-une-connexion-à-la-base-de-données-sqlite-en-utilisant-la-fonction-dbconnect.-le-driver-à-utiliser-sera-sqlite.-quelles-sont-les-tables-présentes-dans-la-table-vous-pourrez-utiliser-la-fonction-dblisttables.",
    "href": "posts/Excercices-TD/semaine_3.html#importez-la-librairie-rsqlite-et-ouvrez-une-connexion-à-la-base-de-données-sqlite-en-utilisant-la-fonction-dbconnect.-le-driver-à-utiliser-sera-sqlite.-quelles-sont-les-tables-présentes-dans-la-table-vous-pourrez-utiliser-la-fonction-dblisttables.",
    "title": "Semaine 3",
    "section": "4. Importez la librairie RSQLite, et ouvrez une connexion à la base de données sqlite en utilisant la fonction dbConnect. Le driver à utiliser sera SQLite(). Quelles sont les tables présentes dans la table ? Vous pourrez utiliser la fonction dbListTables.",
    "text": "4. Importez la librairie RSQLite, et ouvrez une connexion à la base de données sqlite en utilisant la fonction dbConnect. Le driver à utiliser sera SQLite(). Quelles sont les tables présentes dans la table ? Vous pourrez utiliser la fonction dbListTables.\n\ncon &lt;- dbConnect(RSQLite::SQLite(), dbname = \"data/data.sqlite\")\ntables &lt;- dbListTables(con)\nprint(tables)\n\n[1] \"olympics_athletes\" \"tokyo_athletes\"    \"tokyo_medals\"     \n[4] \"tokyo_teams\"      \n\n\nLes tables presentes dans la table sont : “tokyo_medals” “tokyo_teams”"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#créez-deux-nouvelles-tables-dans-la-base-de-données-à-laide-de-la-fonction-dbwritetable.-les-tables-sappeleront-respectivement-olympics_athletes-et-tokyo_athletes-pour-les-fichiers-olympics_athletes.json-et-tokyo_athletes.parquet.",
    "href": "posts/Excercices-TD/semaine_3.html#créez-deux-nouvelles-tables-dans-la-base-de-données-à-laide-de-la-fonction-dbwritetable.-les-tables-sappeleront-respectivement-olympics_athletes-et-tokyo_athletes-pour-les-fichiers-olympics_athletes.json-et-tokyo_athletes.parquet.",
    "title": "Semaine 3",
    "section": "5. Créez deux nouvelles tables dans la base de données à l’aide de la fonction dbWriteTable. Les tables s’appeleront respectivement olympics_athletes et tokyo_athletes pour les fichiers olympics_athletes.json et tokyo_athletes.parquet.",
    "text": "5. Créez deux nouvelles tables dans la base de données à l’aide de la fonction dbWriteTable. Les tables s’appeleront respectivement olympics_athletes et tokyo_athletes pour les fichiers olympics_athletes.json et tokyo_athletes.parquet.\n\ndbWriteTable(con, \"olympics_athletes\", olympics_athletes,  overwrite = TRUE ) \ndbWriteTable(con, \"tokyo_athletes\",tokyo_athletes,  overwrite = TRUE )\n\ndbListTables(con)\n\n[1] \"olympics_athletes\" \"tokyo_athletes\"    \"tokyo_medals\"     \n[4] \"tokyo_teams\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#inspectez-la-table-olympics_athletes-en-utilisant-la-fonction-dblistfields.-quelles-sont-les-colonnes-de-la-table",
    "href": "posts/Excercices-TD/semaine_3.html#inspectez-la-table-olympics_athletes-en-utilisant-la-fonction-dblistfields.-quelles-sont-les-colonnes-de-la-table",
    "title": "Semaine 3",
    "section": "6. Inspectez la table olympics_athletes en utilisant la fonction dbListFields. Quelles sont les colonnes de la table ?",
    "text": "6. Inspectez la table olympics_athletes en utilisant la fonction dbListFields. Quelles sont les colonnes de la table ?\nLes colonnes sont :\n\ndbListFields(con, \"olympics_athletes\")\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#importez-cette-table-depuis-la-base-de-données-en-utilisant-la-fonction-dbreadtable.-convertissez-la-table-en-tibble-en-utilisant-la-fonction-as_tibble.",
    "href": "posts/Excercices-TD/semaine_3.html#importez-cette-table-depuis-la-base-de-données-en-utilisant-la-fonction-dbreadtable.-convertissez-la-table-en-tibble-en-utilisant-la-fonction-as_tibble.",
    "title": "Semaine 3",
    "section": "7. Importez cette table depuis la base de données en utilisant la fonction dbReadTable. Convertissez la table en tibble en utilisant la fonction as_tibble.",
    "text": "7. Importez cette table depuis la base de données en utilisant la fonction dbReadTable. Convertissez la table en tibble en utilisant la fonction as_tibble.\n\nolympics_athletes &lt;- dbReadTable(con, \"olympics_athletes\") \n  olympics_athletes &lt;- as_tibble(olympics_athletes)\nclass(olympics_athletes)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#convertissez-la-colonne-sex-en-variable-catégorielle-avec-la-fonction-mutate.",
    "href": "posts/Excercices-TD/semaine_3.html#convertissez-la-colonne-sex-en-variable-catégorielle-avec-la-fonction-mutate.",
    "title": "Semaine 3",
    "section": "8. Convertissez la colonne Sex en variable catégorielle avec la fonction mutate.",
    "text": "8. Convertissez la colonne Sex en variable catégorielle avec la fonction mutate.\n\nolympics_athletes &lt;- olympics_athletes |&gt;\n  mutate(Sex = as.factor(Sex))\n\nstr(olympics_athletes)\n\ntibble [269,731 × 13] (S3: tbl_df/tbl/data.frame)\n $ ID    : int [1:269731] 1 2 3 4 5 5 5 5 5 5 ...\n $ Name  : chr [1:269731] \"A Dijiang\" \"A Lamusi\" \"Gunnar Nielsen Aaby\" \"Edgar Lindenau Aabye\" ...\n $ Sex   : Factor w/ 2 levels \"F\",\"M\": 2 2 2 2 1 1 1 1 1 1 ...\n $ Age   : int [1:269731] 24 23 24 34 21 21 25 25 27 27 ...\n $ Height: int [1:269731] 180 170 NA NA 185 185 185 185 185 185 ...\n $ Weight: num [1:269731] 80 60 NA NA 82 82 82 82 82 82 ...\n $ Team  : chr [1:269731] \"China\" \"China\" \"Denmark\" \"Denmark/Sweden\" ...\n $ NOC   : chr [1:269731] \"CHN\" \"CHN\" \"DEN\" \"DEN\" ...\n $ Games : chr [1:269731] \"1992 Summer\" \"2012 Summer\" \"1920 Summer\" \"1900 Summer\" ...\n $ City  : chr [1:269731] \"Barcelona\" \"London\" \"Antwerpen\" \"Paris\" ...\n $ Sport : chr [1:269731] \"Basketball\" \"Judo\" \"Football\" \"Tug-Of-War\" ...\n $ Event : chr [1:269731] \"Basketball Men's Basketball\" \"Judo Men's Extra-Lightweight\" \"Football Men's Football\" \"Tug-Of-War Men's Tug-Of-War\" ...\n $ Medal : chr [1:269731] NA NA NA \"Gold\" ..."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#créez-deux-colonnes-à-partir-de-la-colonne-games.",
    "href": "posts/Excercices-TD/semaine_3.html#créez-deux-colonnes-à-partir-de-la-colonne-games.",
    "title": "Semaine 3",
    "section": "9. Créez deux colonnes à partir de la colonne Games.",
    "text": "9. Créez deux colonnes à partir de la colonne Games.\nLa première colonne Year sera une colonne de type integer contenant l’année des jeux. La deuxième colonne isSummer sera une colonne booléenne qui indiquera si les jeux sont des jeux d’été ou d’hiver. Vous pourrez utiliser la fonction separate_wider_delim de tidyr notamment.\n\nolympics_athletes &lt;- olympics_athletes |&gt;\n  separate(Games, into = c(\"Year\", \"isSummer\"), sep = \" \") |&gt;\n  mutate(\n    Year = as.integer(Year),\n    isSummer = isSummer == \"Summer\"\n  )"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#calculez-la-moyenne-dage-des-athletes-pour-chacune-des-éditions-des-jo-dété.-quelle-édition-a-compté-les-athlètes-les-plus-jeunes-les-plus-vieux",
    "href": "posts/Excercices-TD/semaine_3.html#calculez-la-moyenne-dage-des-athletes-pour-chacune-des-éditions-des-jo-dété.-quelle-édition-a-compté-les-athlètes-les-plus-jeunes-les-plus-vieux",
    "title": "Semaine 3",
    "section": "10. Calculez la moyenne d’age des athletes pour chacune des éditions des JO d’été. Quelle édition a compté les athlètes les plus jeunes ? Les plus vieux ?",
    "text": "10. Calculez la moyenne d’age des athletes pour chacune des éditions des JO d’été. Quelle édition a compté les athlètes les plus jeunes ? Les plus vieux ?\n\nresultat &lt;- olympics_athletes |&gt;\n  filter(isSummer==TRUE)|&gt;\n   group_by(Year)|&gt;\n   summarise(age_moyenne = mean(Age, na.rm = TRUE)) |&gt;\n  mutate(\n    plus_jeunes = age_moyenne== min(age_moyenne),\n    plus_vieux = age_moyenne == max(age_moyenne)\n  ) |&gt;\n  filter(plus_jeunes | plus_vieux)\n\nresultat\n\n# A tibble: 2 × 4\n   Year age_moyenne plus_jeunes plus_vieux\n  &lt;int&gt;       &lt;dbl&gt; &lt;lgl&gt;       &lt;lgl&gt;     \n1  1896        23.6 TRUE        FALSE     \n2  1932        30.2 FALSE       TRUE"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_3.html#quelle-est-la-discipline-des-jo-dété-dont-la-taille-des-athlètes-féminines-est-la-plus-grande",
    "href": "posts/Excercices-TD/semaine_3.html#quelle-est-la-discipline-des-jo-dété-dont-la-taille-des-athlètes-féminines-est-la-plus-grande",
    "title": "Semaine 3",
    "section": "11. Quelle est la discipline des JO d’été dont la taille des athlètes féminines est la plus grande ?",
    "text": "11. Quelle est la discipline des JO d’été dont la taille des athlètes féminines est la plus grande ?\nQuelle a été cette discipline au cours de chacune des éditions ? Calculez le nombre de fois où chaque discipline a été la discipline avec les plus grandes athlètes.\n\nfemmes_taille_sport &lt;- olympics_athletes |&gt;\n  filter(Sex == \"F\", isSummer == TRUE)|&gt;\n  group_by(Sport) |&gt;\n  summarise(taille_moyenne = mean(Height, na.rm = TRUE)) |&gt;\n  arrange(desc(taille_moyenne))|&gt;\n  slice(1)\n\nfemmes_taille_sport\n\n# A tibble: 1 × 2\n  Sport      taille_moyenne\n  &lt;chr&gt;               &lt;dbl&gt;\n1 Basketball           182.\n\n\n\ndiscipline_plus_grandes_par_edition &lt;- olympics_athletes |&gt;\n  filter(Sex == \"F\", isSummer == TRUE) |&gt;\n  group_by(Year, Sport) |&gt;\n  summarise(taille_moyenne = mean(Height, na.rm = TRUE), .groups = \"drop\") |&gt;\n  # Filtrer les lignes où la taille moyenne n'est pas NaN\n  filter(!is.na(taille_moyenne)) |&gt;\n  group_by(Year) |&gt;\n  slice_max(order_by = taille_moyenne, n = 1) |&gt;\n  ungroup()\n\ndiscipline_plus_grandes_par_edition\n\n# A tibble: 23 × 3\n    Year Sport         taille_moyenne\n   &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;\n 1  1920 Swimming                166.\n 2  1924 Fencing                 168.\n 3  1928 Fencing                 172.\n 4  1932 Fencing                 173.\n 5  1936 Fencing                 178 \n 6  1948 Swimming                172.\n 7  1952 Athletics               168.\n 8  1956 Equestrianism           170.\n 9  1960 Athletics               169.\n10  1964 Volleyball              171.\n# ℹ 13 more rows"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Bienvenue sur mon Blog",
    "section": "",
    "text": "Je suis ravie de vous accueillir sur mon blog, où je retrace mon parcours académique à travers mon master ECAP (Économétrie et Statistique), une formation axée sur l’analyse de données et la programmation.\nAvant de nous lancer, je tenais à partager avec vous une image des frailejones :)"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html",
    "href": "posts/Excercices-TD/semaine_2.html",
    "title": "Semaine 2",
    "section": "",
    "text": "# TD 2\nlibrary(rvest)\nlibrary(purrr)\nlibrary(stringr)"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#lancer-la-commande-suivante",
    "href": "posts/Excercices-TD/semaine_2.html#lancer-la-commande-suivante",
    "title": "Semaine 2",
    "section": "1 . Lancer la commande suivante :",
    "text": "1 . Lancer la commande suivante :\n\nlist_tables &lt;-\n  session(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |&gt;\n  html_elements(\".wikitable\") |&gt;\n  html_table()\n\n\nhead(list_tables, n= 1)\n\n[[1]]\n# A tibble: 31 × 11\n   Discipline   Discipline   Années `Nombre de` `Nombre de` `médailles décernés`\n   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;               \n 1 \"Discipline\" Discipline   Années Éditions    Épreuves(e… Or                  \n 2 \"\"           Athlétisme   Depui… 29          48          1028                \n 3 \"\"           Aviron       Depui… 28          14          269                 \n 4 \"\"           Badminton    Depui… 8           5           39                  \n 5 \"\"           Basket-ball  Depui… 20          4           32                  \n 6 \"\"           Boxe         1904,… 26          13          266                 \n 7 \"\"           Canoë-kayak  Depui… 20          16          242                 \n 8 \"\"           Cyclisme(ho… Depui… 29          22          263                 \n 9 \"\"           Équitation   1900,… 26          6           151                 \n10 \"\"           Escrime      Depui… 29          12          223                 \n# ℹ 21 more rows\n# ℹ 5 more variables: `médailles décernés` &lt;chr&gt;, `médailles décernés` &lt;chr&gt;,\n#   `médailles décernés` &lt;chr&gt;,\n#   `Athlète(s) avec le plus de médailles (Or-Argent-Bronze)` &lt;chr&gt;,\n#   `Athlète(s) avec le plus de médailles d'or` &lt;chr&gt;"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#que-sest-il-passé-que-contient-lobjet-list_tables",
    "href": "posts/Excercices-TD/semaine_2.html#que-sest-il-passé-que-contient-lobjet-list_tables",
    "title": "Semaine 2",
    "section": "2. Que s’est-il passé ? Que contient l’objet list_tables ?",
    "text": "2. Que s’est-il passé ? Que contient l’objet list_tables ?\nLa commande récupère les informations de Wikipedia (image ci-dessous), qui contient une liste de tibbles, chacun représentant un tableau qui contient les informations sur les médaillés olympiques.\n\nNous allons tout d’abord nous intéresser à la première table, les jeux olympiques d’été.\nCréer un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables.\n\ndata_medailles_sport_ete &lt;-  list_tables[[1]]\n\nLa table n’est pas bien formatée.\nJe supprime la première colonne, la première ligne et je modifie les noms de colonnes\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1, -1]\n\ncolnames(data_medailles_sport_ete) &lt;- c(\"Discipline\", \"Annees\", \"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \"Athletes_or\")\n\nstr(data_medailles_sport_ete)\n\ntibble [30 × 10] (S3: tbl_df/tbl/data.frame)\n $ Discipline        : chr [1:30] \"Athlétisme\" \"Aviron\" \"Badminton\" \"Basket-ball\" ...\n $ Annees            : chr [1:30] \"Depuis 1896\" \"Depuis 1900\" \"Depuis 1992\" \"Depuis 1936\" ...\n $ Editions          : chr [1:30] \"29\" \"28\" \"8\" \"20\" ...\n $ Epreuves_2020     : chr [1:30] \"48\" \"14\" \"5\" \"4\" ...\n $ Or                : chr [1:30] \"1028\" \"269\" \"39\" \"32\" ...\n $ Argent            : chr [1:30] \"1030\" \"268\" \"39\" \"32\" ...\n $ Bronze            : chr [1:30] \"1027\" \"273\" \"43\" \"32\" ...\n $ Total             : chr [1:30] \"3085\" \"810\" \"121\" \"96\" ...\n $ Athletes_medailles: chr [1:30] \"Paavo Nurmi (FIN) (9-3-0)\" \"Elisabeta Lipă (ROU) (5-2-1)\" \"Gao Ling (CHN) (2-1-1)\" \"Teresa Edwards (USA) (4-0-1)\" ...\n $ Athletes_or       : chr [1:30] \"Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)\" \"Elisabeta Lipă (ROU) (5-2-1) Georgeta Damian (ROU) (5-0-1) Steven Redgrave (GBR) (5-0-1)\" \"Gao Ling (CHN) (2-1-1) Kim Dong-moon (KOR) (2-0-1) Zhang Nan (CHN) (2-0-1) Ge Fei (CHN) (2-0-0) Gu Jun (CHN) (2\"| __truncated__ \"Teresa Edwards (USA) (4-0-1) Sue Bird (USA) (4-0-0) Tamika Catchings (USA) (4-0-0) Lisa Leslie (USA) (4-0-0) Di\"| __truncated__ ...\n\n\nLes colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total seront converties en colonnes d’entiers.\n\ndata_medailles_sport_ete[c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")] &lt;- lapply(data_medailles_sport_ete[c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")], as.integer)\n\nstr(data_medailles_sport_ete)\n\ntibble [30 × 10] (S3: tbl_df/tbl/data.frame)\n $ Discipline        : chr [1:30] \"Athlétisme\" \"Aviron\" \"Badminton\" \"Basket-ball\" ...\n $ Annees            : chr [1:30] \"Depuis 1896\" \"Depuis 1900\" \"Depuis 1992\" \"Depuis 1936\" ...\n $ Editions          : int [1:30] 29 28 8 20 26 20 29 26 29 27 ...\n $ Epreuves_2020     : int [1:30] 48 14 5 4 13 16 22 6 12 2 ...\n $ Or                : int [1:30] 1028 269 39 32 266 242 263 151 223 34 ...\n $ Argent            : int [1:30] 1030 268 39 32 266 241 261 149 223 34 ...\n $ Bronze            : int [1:30] 1027 273 43 32 472 243 260 148 221 35 ...\n $ Total             : int [1:30] 3085 810 121 96 1004 726 784 448 667 103 ...\n $ Athletes_medailles: chr [1:30] \"Paavo Nurmi (FIN) (9-3-0)\" \"Elisabeta Lipă (ROU) (5-2-1)\" \"Gao Ling (CHN) (2-1-1)\" \"Teresa Edwards (USA) (4-0-1)\" ...\n $ Athletes_or       : chr [1:30] \"Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)\" \"Elisabeta Lipă (ROU) (5-2-1) Georgeta Damian (ROU) (5-0-1) Steven Redgrave (GBR) (5-0-1)\" \"Gao Ling (CHN) (2-1-1) Kim Dong-moon (KOR) (2-0-1) Zhang Nan (CHN) (2-0-1) Ge Fei (CHN) (2-0-0) Gu Jun (CHN) (2\"| __truncated__ \"Teresa Edwards (USA) (4-0-1) Sue Bird (USA) (4-0-0) Tamika Catchings (USA) (4-0-0) Lisa Leslie (USA) (4-0-0) Di\"| __truncated__ ..."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#quelles-sont-les-3-disciplines-avec-le-plus-de-médailles-distribuées-depuis-le-début-de-lhistoire-des-jeux-olympiques",
    "href": "posts/Excercices-TD/semaine_2.html#quelles-sont-les-3-disciplines-avec-le-plus-de-médailles-distribuées-depuis-le-début-de-lhistoire-des-jeux-olympiques",
    "title": "Semaine 2",
    "section": "3. Quelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?",
    "text": "3. Quelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?\nà l’aide de : order, nous pouvons trier les indices des lignes du dataframe en fonction de la colonne Total, en ordre décroissant (decreasing = TRUE signifie que les valeurs les plus élevées viennent en premier).\n\ntop3_disciplines &lt;- data_medailles_sport_ete[order(data_medailles_sport_ete$Total, decreasing = TRUE), ][1:3,]\n\ncat(\"Les 3 disciplines avec le plus de médailles sont :\", paste(top3_disciplines$Discipline, collapse = \", \"), \"\\n\")\n\nLes 3 disciplines avec le plus de médailles sont : Athlétisme, Natation(hommes, femmes), Lutte"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#quelles-sont-les-disciplines-avec-le-moins-dépreuves-en-2020",
    "href": "posts/Excercices-TD/semaine_2.html#quelles-sont-les-disciplines-avec-le-moins-dépreuves-en-2020",
    "title": "Semaine 2",
    "section": "4. Quelles sont les disciplines avec le moins d’épreuves en 2020 ?",
    "text": "4. Quelles sont les disciplines avec le moins d’épreuves en 2020 ?\n\ndisc_moins_epreuves_2020 &lt;- data_medailles_sport_ete[(data_medailles_sport_ete$Epreuves_2020 == (min(data_medailles_sport_ete$Epreuves_2020))),] \n# utilisation du min et == pour trouver les epreuves avec le moins d'épreuves\n\ncat(\"Les disciplines avec le moins d'éprevues en 2020 sont:\", paste(disc_moins_epreuves_2020$Discipline, collapse = \",\"))\n\nLes disciplines avec le moins d'éprevues en 2020 sont: Football,Golf,Handball,Hockey sur gazon,Natation synchronisée,Pentathlon moderne,Volley-ball,Water polo"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#création-de-fonction-calcul_nb_editions",
    "href": "posts/Excercices-TD/semaine_2.html#création-de-fonction-calcul_nb_editions",
    "title": "Semaine 2",
    "section": "5. Création de fonction calcul_nb_editions",
    "text": "5. Création de fonction calcul_nb_editions\nLa colonne Editions nous renseigne sur le nombre total d’apparence des disciplines aux JO d’été. Nous souhaitons vérifier ce calcul en implémentant notre propre fonction calcul_nb_editions_int. Dans un premier temps, la fonction calcul_nb_editions prendra en entrée un paramètre depuis, de type entier, qui représente depuis quelle année la discipline est au programme.\n\n# Premier partie, fonction calcul de nombre d'editions \ncalcul_nb_editions &lt;- function(depuis){\n  # Calcul de l'année en cours pour connaitre le nombre d'année au total\n  annee_actuelle &lt;- as.integer(format(Sys.Date(), \"%Y\"))\n  annees_editions &lt;- seq(depuis, annee_actuelle, 4)\n  nb_edtions &lt;- length(annees_editions)\n  return(nb_edtions)\n}\ncalcul_nb_editions(1896)\n\n[1] 33\n\n# Sys.Date() est une fonction en R qui retourne la date courante.\n# Formate cette date pour extraire l'année en cours sous forme de chaîne de caractères avec format(…, \"%Y\") et as.integer convertit cette chaîne en un entier avec as.integer()\n\nLa deuxieme partie, consiste à verifier la colonne Editions\n\nstr(data_medailles_sport_ete$Annees)\n\n chr [1:30] \"Depuis 1896\" \"Depuis 1900\" \"Depuis 1992\" \"Depuis 1936\" ...\n\n\nPour vérifier la colonne Éditions, il est nécessaire de récupérer les informations relatives aux années de participation aux Jeux Olympiques, que ce soit par année individuelle, par plage d’années, ou en continu depuis une année donnée. La colonne des années est définie comme une chaîne de caractères; Il faut donc créer une fonction qui extraira toutes les années et les comptabilisera.\n\ncalcul_nb_editions_str &lt;- function(annee_texte){\n  annee_actuelle &lt;- as.integer(format(Sys.Date(), \"%Y\"))\n  annees &lt;- unlist(str_extract_all(annee_texte, \"\\\\b\\\\d{4}\\\\b\")) \n  # Extraire toutes les années individuelles\n   depuis_annees &lt;- as.integer(unlist(str_extract_all(annee_texte, regex(\"(?&lt;=depuis )\\\\d{4}\", ignore_case = TRUE)))) \n   # Extraire les années de départ pour \"depuis / Depuis \"\n  \n   # Traiter les plages d'années\n  plages &lt;- str_extract_all(annee_texte, \"\\\\d{4}–\\\\d{4}\") # Extraire les plages d'années\n  plages &lt;- unlist(plages)\n  for (plage in plages) {\n    annees_debut_fin &lt;- as.integer(unlist(str_extract_all(plage, \"\\\\d{4}\")))\n    annees &lt;- c(annees, seq(annees_debut_fin[1], annees_debut_fin[2], by = 4))\n  }\n  # Ajouter les éditions depuis les années spécifiques jusqu'à l'année actuelle\n  for (depuis_annee in depuis_annees) {\n    annees_depuis &lt;- seq(depuis_annee, annee_actuelle, by = 4)\n    annees &lt;- c(annees, annees_depuis)\n  }\n   # Calculer le nombre d'éditions uniques\n  nb_editions &lt;- length(unique(as.integer(annees)))\n  \n  return(nb_editions)\n}\n\n\ncomparatif &lt;- data.frame(\n  Edtions = data_medailles_sport_ete$Editions, \n  Editions_a_2024 = sapply(data_medailles_sport_ete$Annees, calcul_nb_editions_str))\nhead(comparatif)\n\n  Edtions Editions_a_2024\n1      29              33\n2      28              32\n3       8               9\n4      20              23\n5      26              29\n6      20              23\n\n\nPlusieurs différences sont présentes dans le comparatif, ce qui peut être expliqué par le fait que notre méthode de calcul n’inclut pas les annulations des Jeux Olympiques. Par exemple, les jeux de 1916, 1940 et 1944 n’ont pas eu lieu en raison des deux guerres mondiales, réduisant ainsi le nombre d’éditions effectivement réalisées. De plus, la dernière modification de l’article Wikipedia datant d’août 2023 pourrait indiquer que l’article a intégré les informations les plus récentes disponibles à cette période, y compris potentiellement les Jeux Olympiques de Tokyo 2020 qui ont été reportés à 2021 à cause de la pandémie de COVID-19.\n\n\n\n\n\n\nregex(…, ignore_case = TRUE)\n\n\n\nEst utilisé pour créer une expression régulière avec l’option ignore_case = TRUE, rendant la recherche insensible à la casse."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#fonction-calcul_nb_editions_str",
    "href": "posts/Excercices-TD/semaine_2.html#fonction-calcul_nb_editions_str",
    "title": "Semaine 2",
    "section": "6. Fonction calcul_nb_editions_str",
    "text": "6. Fonction calcul_nb_editions_str\nDans certains cas, les disciplines ont été au programme de façon discontinue. Proposez une nouvelle fonction calcul_nb_editions_str qui prendra cette fois-ci en entrée des chaînes de caractères. Par exemple, l’appel suivant: calcul_nb_editions_str(“1896, 1904, depuis 1920”)\n\n\n\n\n\n\nNote\n\n\n\nLa fonction calcul_nb_editions_str a déjà était conçue pour extraire des années individuelles, traiter des plages d’années, et compter les éditions depuis une certaine année jusqu’à l’année actuelle dans la question 5.\n\n\n\ncalcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\n[1] 29\n\n\nCepandant si les années sont presentés comme une liste ou un vecteur (incluant des valeurs individuelles ), il faut une function tel que :\n\ncalcul_nb_editions.integer &lt;- function(annees_participation) {\n  nb_participations &lt;- length(unique(annees_participation))\n  return(nb_participations)\n}\n\ncalcul_nb_editions.integer(1900)\n\n[1] 1"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#fonctions-calcul_nb_editions.integer-et-calcul_nb_editions.character",
    "href": "posts/Excercices-TD/semaine_2.html#fonctions-calcul_nb_editions.integer-et-calcul_nb_editions.character",
    "title": "Semaine 2",
    "section": "7. Fonctions calcul_nb_editions.integer et ’calcul_nb_editions.character",
    "text": "7. Fonctions calcul_nb_editions.integer et ’calcul_nb_editions.character\nDéfinissez une fonction générique calcul_nb_editions et deux implémentations calcul_nb_editions.integer et ’calcul_nb_editions.character. Quels résultats donnent les appels : calcul_nb_editions(2000) calcul_nb_editions(“1904–1924, depuis 1948”)\n\n# Définition de la fonction génerique\ncalcul_nb_editions &lt;- function(x) {\n  UseMethod(\"calcul_nb_editions\")\n}\n\nPour les entiers, nous utilisons la fonction calcul_nb_additions.integer, mais nous la compléterons avec une fonction calcul_nb_editions.numeric car en R, les nombres sans point décimal sont souvent traités comme des numériques (numeric), même s’ils représentent des entiers. Cela signifie que si l’on teste un nombre tel que 2000 avec calcul_nb_editions, R cherchera une méthode applicable aux classes numeric ou double, et non integer\n\n# méthode existante pour les entiers\ncalcul_nb_editions.integer &lt;- function(x) {\n  nb_participations &lt;- length(unique(x))\n  return(nb_participations)\n}\n\n#  méthode pour les numériques \ncalcul_nb_editions.numeric &lt;- function(x) {\n  # Vérifier si x est entier\n  if (x == floor(x)) {\n    # Convertir x en entier et appeler la méthode pour 'integer'\n    return(calcul_nb_editions.integer(as.integer(x)))\n  } else {\n    stop(\"La méthode n'est définie que pour les entiers\")\n  }\n}\n\nPour les Chaînes de Caractères\n\ncalcul_nb_editions.character &lt;- function(x) {\n  annee_actuelle &lt;- as.integer(format(Sys.Date(), \"%Y\"))\n  annees &lt;- unlist(str_extract_all(x, \"\\\\b\\\\d{4}\\\\b\")) # Extraire toutes les années individuelles\n  depuis_annees &lt;- as.integer(unlist(str_extract_all(x, regex(\"(?&lt;=depuis )\\\\d{4}\", ignore_case = TRUE)))) # Extraire les années de départ pour \"depuis / Depuis\"\n  \n  # plages d'années\n  plages &lt;- str_extract_all(x, \"\\\\d{4}–\\\\d{4}\") # Extraire les plages d'années\n  plages &lt;- unlist(plages)\n  for (plage in plages) {\n    annees_debut_fin &lt;- as.integer(unlist(str_extract_all(plage, \"\\\\d{4}\")))\n    annees &lt;- c(annees, seq(annees_debut_fin[1], annees_debut_fin[2], by = 4))\n  }\n  # Ajout les éditions depuis les années spécifiques jusqu'à l'année actuelle\n  for (depuis_annee in depuis_annees) {\n    annees_depuis &lt;- seq(depuis_annee, annee_actuelle, by = 4)\n    annees &lt;- c(annees, annees_depuis)\n  }\n  # Calcule le nombre d'éditions uniques\n  nb_editions &lt;- length(unique(as.integer(annees)))\n  \n  return(nb_editions)\n}\n\n\ncalcul_nb_editions(2000)\ncalcul_nb_editions(\"1904–1924, depuis 1948\")"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#fonction-calcul_medailles_individuelles",
    "href": "posts/Excercices-TD/semaine_2.html#fonction-calcul_medailles_individuelles",
    "title": "Semaine 2",
    "section": "8. Fonction < calcul_medailles_individuelles>",
    "text": "8. Fonction &lt; calcul_medailles_individuelles&gt;\nEn Athlétisme, le Finlandais Paavo Nurmi détient le record de médailles avec 12 médailles obtenues lors des JO d’hiver.\nImplémentez une fonction &lt; calcul_medailles_individuelles&gt; qui détermine le nombre de médaille maximal a été obtenu par un athlète lors d’olympiades. Note : s’il y a plusieurs athlètes à égalité, alors la cellule comporte plusieurs éléments, et une manipulation de la chaîne de caractères est nécessaire.\n\nLes jeux olympiques d’hiver se trouvent dans la list_tables, 2eme\n\n\ndata_medailles_sport_hiver &lt;- list_tables[[2]]\ndata_medailles_sport_hiver &lt;- data_medailles_sport_hiver[-1,-1]\ndata_medailles_sport_hiver$Discipline\n\n [1] \"Biathlon\"                            \n [2] \"Bobsleigh\"                           \n [3] \"Combiné nordique\"                    \n [4] \"Curling\"                             \n [5] \"Hockey sur glace\"                    \n [6] \"Luge\"                                \n [7] \"Patinage artistique\"                 \n [8] \"Patinage de vitesse\"                 \n [9] \"Patinage de vitesse sur piste courte\"\n[10] \"Saut à ski\"                          \n[11] \"Skeleton\"                            \n[12] \"Ski acrobatique\"                     \n[13] \"Ski alpin\"                           \n[14] \"Ski de fond\"                         \n[15] \"Snowboard\"                           \n\n\n\n\n\n\n\n\nWarning\n\n\n\nLa discipline Athétisme fait partie des jeux olympiques d’été et non d’hiver, alors je retourne au df été\n\n\nLa colonne N° 9 designe les Athlète(s) avec le plus de médailles (Or-Argent-Bronze) de la maniere suivante\n\nhead(data_medailles_sport_ete$Athletes_medailles)\n\n[1] \"Paavo Nurmi (FIN) (9-3-0)\"                                                                                                                                                                                                                                                                              \n[2] \"Elisabeta Lipă (ROU) (5-2-1)\"                                                                                                                                                                                                                                                                           \n[3] \"Gao Ling (CHN) (2-1-1)\"                                                                                                                                                                                                                                                                                 \n[4] \"Teresa Edwards (USA) (4-0-1)\"                                                                                                                                                                                                                                                                           \n[5] \"László Papp (HUN) (3-0-0) Félix Savón (CUB) (3-0-0) Teófilo Stevenson (CUB) (3-0-0) Roniel Iglesias (CUB) (2-0-1) Boris Lagutin (URS) (2-0-1) Oleg Saitov (RUS) (2-0-1) Zou Shiming (CHN) (2-0-1) Roberto Cammarelle (ITA) (1-1-1) Zbigniew Pietrzykowski (POL) (0-1-2) Arnold Vanderlyde (NED) (0-0-3)\"\n[6] \"Birgit Fischer (GER) (8-4-0)\"                                                                                                                                                                                                                                                                           \n\n\nLa fonction calcul_medailles_individuelles analyse une chaîne de caractères listant des athlètes avec leurs médailles. Nous créons un dataframe pour recueillir les noms des athlètes et leur total de médailles à partir d’une chaîne de caractères. En utilisant des expressions régulières, nous séparons d’abord chaque athlète et ses médailles. Nous nettoyons ensuite ces données en retirant les parenthèses et en isolant le nom de l’athlète du détail de ses médailles (or, argent, bronze). Après avoir converti ces informations en nombres, nous calculons le total des médailles pour chaque athlète. Ces informations, comprenant le nom de l’athlète et son total de médailles, sont ensuite ajoutées au dataframe. Finalement, ce dataframe, qui synthétise le nom des athlètes et leur performance en termes de médailles, nous est retourné.\n\ncalcul_medailles_individuelles &lt;- function(athletes_medailles) {\n  # initialiser un dataframe pour stocker les résultats\n  resultats_df &lt;- data.frame(Athlete = character(), TotalMedailles = integer(), stringsAsFactors = FALSE)\n  \n  # séparation des athlètes en utilisant une regex plus robuste\n  athletes_details &lt;- strsplit(athletes_medailles, \"\\\\)\\\\s*(?=[A-Z])\", perl = TRUE)[[1]]\n  \n  for (detail in athletes_details) {\n    detail &lt;- gsub(\"[()]\", \"\", detail) # Nettoyer la chaîne\n    name_medals_parts &lt;- strsplit(detail, \"\\\\s(?=\\\\d+-\\\\d+-\\\\d+)\", perl = TRUE)[[1]] # Séparer nom des médailles\n    \n    if (length(name_medals_parts) &lt; 2) next # Passer si le format n'est pas correct\n    \n    athlete_name &lt;- name_medals_parts[1]\n    medals_info &lt;- strsplit(name_medals_parts[2], \"-\")[[1]]\n    total_medals &lt;- sum(as.integer(medals_info))\n    \n    resultats_df &lt;- rbind(resultats_df, data.frame(Athlete = athlete_name, TotalMedailles = total_medals, stringsAsFactors = FALSE))\n  }\n  \n  return(resultats_df)\n}\n\n\n\n\n\n\n\nPourquoi utiliser perl = TRUE ?\n\n\n\nFonctionnalités Avancées : Le moteur Perl offre des fonctionnalités d’expressions régulières plus avancées, telles que les assertions positives et négatives en amont (?= et ?!), les assertions de mots limites (\\b), et d’autres constructions complexes qui ne sont pas toujours supportées ou qui peuvent avoir un comportement différent dans le moteur d’expressions régulières de base de R.\n\n\n\n# exemple de la fonction pour la ligne 29\ndata_medailles_sport_ete$Athletes_medailles[29]\n\n[1] \"Ana Fernández (CUB) (3-0-1) Kerri Walsh (USA) (3-0-1) Inna Ryskal (URS) (2-2-0) Sérgio Dutra Santos (BRA) (2-2-0) Sergey Tetyukhin (RUS) (1-1-2)\"\n\ncalcul_medailles_individuelles(data_medailles_sport_ete$Athletes_medailles[29])\n\n                  Athlete TotalMedailles\n1       Ana Fernández CUB              4\n2         Kerri Walsh USA              4\n3         Inna Ryskal URS              4\n4 Sérgio Dutra Santos BRA              4\n5    Sergey Tetyukhin RUS              4"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#quel-est-le-top-3-des-athlètes",
    "href": "posts/Excercices-TD/semaine_2.html#quel-est-le-top-3-des-athlètes",
    "title": "Semaine 2",
    "section": "9. Quel est le top 3 des athlètes ?",
    "text": "9. Quel est le top 3 des athlètes ?\nVous utiliserez la fonction lapply pour appliquer la fonction calcul_medailles_individuelles à chaque élément de la colonne Athletes_medailles\n\n# appliquer la fonction à chaque élément de la colonne Athletes_medailles\nliste_df &lt;- lapply(data_medailles_sport_ete$Athletes_medailles, calcul_medailles_individuelles)\n\n# créer un seul dataframe\ndf_athletes_medailles &lt;- do.call(rbind, liste_df)\n\n# trier le dataframe combiné par TotalMedailles en ordre décroissant et afficher les 3 premiers \ntop_3_athletes &lt;- head(df_athletes_medailles[order(-df_athletes_medailles$TotalMedailles),], 3)\n\nprint(\"Le top 3 des athlètes et leur nombre de médailles sont :\")\n\n[1] \"Le top 3 des athlètes et leur nombre de médailles sont :\"\n\ntop_3_athletes\n\n                   Athlete TotalMedailles\n38      Michael Phelps USA             28\n23    Larissa Latynina URS             18\n18 Edoardo Mangiarotti ITA             13"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#quels-sont-les-3-nationalités-les-plus-représentées-pour-toutes-les-épreuves-au-classement-du-nombre-de-médailles-dor-individuelles-reccueillies",
    "href": "posts/Excercices-TD/semaine_2.html#quels-sont-les-3-nationalités-les-plus-représentées-pour-toutes-les-épreuves-au-classement-du-nombre-de-médailles-dor-individuelles-reccueillies",
    "title": "Semaine 2",
    "section": "10. Quels sont les 3 nationalités les plus représentées, pour toutes les épreuves, au classement du nombre de médailles d’or individuelles reccueillies ?",
    "text": "10. Quels sont les 3 nationalités les plus représentées, pour toutes les épreuves, au classement du nombre de médailles d’or individuelles reccueillies ?\n• Pour ce faire, vous implémenterez une fonction extraire_nationalite_athlete qui à partir d’une chaine de charactère extraira le nombre d’athlète et leur nationalité. Par exemple, la chaine de caractère “Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)” donnera en sortie c(“FIN” = 1, “USA” = 1)\n• Vous utilisez la fonction lapply pour appliquer la fonction à toute la colonne 8. En Athlétisme, le Finlandais Paavo Nurmi détient le record de médailles avec 12 médailles obtenues lors des JO d’hiver\n• Vous agrégerez les résultats de manière à sommer toutes les lignes et à obtenir les 3 nations les plus représentées, et leur effectif.\n\nextraire_nationalite_athlete &lt;- function(texte) {\n  # Extraire les morceaux contenant la nationalité et les médailles d'or\n  matches &lt;- gregexpr(\"\\\\([A-Z]{3}\\\\) \\\\((\\\\d+)-\", texte)\n  nationalites_et_or &lt;- regmatches(texte, matches)\n  \n  # Initialiser un vecteur pour les nationalités\n  nationalites &lt;- vector(\"list\", length(nationalites_et_or[[1]]))\n  \n  for(i in seq_along(nationalites_et_or[[1]])) {\n    match &lt;- nationalites_et_or[[1]][i]\n    nationalite &lt;- substr(match, 2, 4) # Extraire la nationalité\n    or &lt;- as.numeric(substr(match, 8, nchar(match)-1)) # Extraire le nombre de médailles d'or\n    \n    if(or &gt; 0) { # compter seulement si au moins une médaille d'or a été gagnée\n      if(!is.null(nationalites[[nationalite]])) {\n        nationalites[[nationalite]] &lt;- nationalites[[nationalite]] + 1\n      } else {\n        nationalites[[nationalite]] &lt;- 1\n      }\n    }\n  }\n  \n  return(unlist(nationalites))\n}\n\n\nresultats_nationalites &lt;- lapply(data_medailles_sport_ete$Athletes_medailles, extraire_nationalite_athlete)\n\nnationalites_agg &lt;- Reduce(`+`, resultats_nationalites)\n\nWarning in f(init, x[[i]]): longer object length is not a multiple of shorter\nobject length\n\nWarning in f(init, x[[i]]): longer object length is not a multiple of shorter\nobject length\n\n# les 3 nationalités les plus représentées\ntop_3_nationalites &lt;- sort(nationalites_agg, decreasing = TRUE)[1:3]\n\nprint(\"Les 3 nationalités les plus représentées en médailles d'or sont :\")\n\n[1] \"Les 3 nationalités les plus représentées en médailles d'or sont :\"\n\nprint(top_3_nationalites)\n\nCUB HUN URS \n 35  33  33 \n\n\nOn commence par extraire les nationalités et le nombre d’athlètes ayant remporté au moins une médaille d’or de chaque chaîne de caractères fournie. Ensuite, on utilise lapply pour appliquer cette opération à chaque élément de la colonne Athletes_medailles et Reduce pour sommer les résultats et obtenir un compte total par nationalité."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_2.html#utilisation-du-package-purr",
    "href": "posts/Excercices-TD/semaine_2.html#utilisation-du-package-purr",
    "title": "Semaine 2",
    "section": "11. Utilisation du package purr",
    "text": "11. Utilisation du package purr\nIntéressez-vous désormais au deuxième tableau contenu dans list_tables, faisant référence aux JO d’hiver. Appliquez les fonctions calcul_medailles_individuelles et extraire_nationalite_athlete aux deux dernières colonnes, à la manière des questions 9 et 10. Cette fois-ci, vous utiliserez la fonction appropriée du package purrr en lieu et place de lapply. Quelles sont les résultats ? Quelle différence voyez-vous entre lapply et les fonctions de purrr ?\nNous avions precedement récuperé le deuximem tableau, faisant référence aux JO d’hiver, dans un tibble appélé data_medailles_sport_hiver\n\nhead(data_medailles_sport_hiver[9])\n\n# A tibble: 6 × 1\n  `Athlète(s) avec le plus de médailles (Or-Argent-Bronze)`                     \n  &lt;chr&gt;                                                                         \n1 \"Ole Einar Bjørndalen (NOR) (8-4-1)\"                                          \n2 \"Bogdan Musiol (RDA) (1-5-1)\"                                                 \n3 \"Felix Gottwald (AUT) (3-1-3)\"                                                \n4 \"Anna Le Moine (SWE) (2-0-0) Cathrine Lindahl (SWE) (2-0-0) Eva Lund (SWE) (2…\n5 \"Jayna Hefford (CAN) (4-1-0) Hayley Wickenheiser (CAN) (4-1-0)\"               \n6 \"Armin Zöggeler (ITA) (2-1-3)\"                                                \n\n\n\n# appliquer la fonction à chaque élément de la colonne 9 en utilisant map_df pour retourner un dataframe\ndf_athletes_medailles &lt;- map_df(data_medailles_sport_hiver[[9]], calcul_medailles_individuelles)\n\n# Trier le dataframe combiné par TotalMedailles en ordre décroissant et sélectionner les 3 premiers athlètes\ntop_3_athletes &lt;- head(df_athletes_medailles[order(-df_athletes_medailles$TotalMedailles),], 3)\n\n# Affichage du top 3 des athlètes et leur nombre de médailles\nprint(\"Le top 3 des athlètes et leur nombre de médailles sont :\")\n\n[1] \"Le top 3 des athlètes et leur nombre de médailles sont :\"\n\nprint(top_3_athletes)\n\n                    Athlete TotalMedailles\n29        Marit Bjørgen NOR             15\n1  Ole Einar Bjørndalen NOR             13\n18           Ireen Wüst NED             11\n\n\nLa fonction map_df de purrr est utilisée pour appliquer calcul_medailles_individuelles à chaque élément de la colonne sélectionnée et retourner directement un dataframe. Contrairement à lapply, qui retourne une liste, map_df simplifie le processus en combinant directement les résultats dans un dataframe, éliminant ainsi le besoin d’utiliser do.call(rbind, …) pour fusionner les résultats."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html",
    "href": "posts/Excercices-TD/semaine_1.html",
    "title": "Semaine 1",
    "section": "",
    "text": "Dans cette section, vous trouverez les solutions pour les exercices des semaines 1, 2 et 3, ainsi que les réponses aux questions posées dans l’exercice 4 et au cours de l’élaboration du projet.\nVoici quelques précisions avant de commencer :\n\nIl est important de noter que toutes les librairies nécessaires à la réalisation de ces exercices sont téléchargées dans la première partie. (l’installation de certains packages peut être requise avant l’utilisation de la librairie)\nL’encodage des caractères utilisé est UTF-8\nLa licence MIT a été choisi pour ce projet\nLa création d’un projet pour chaque ensemble d’exercices (par semaine) et de scripts a été réalisée afin de respecter les consignes et conseils. Cependant, ici, vous trouverez l’ensemble de toutes les semaines réunies\n\n\n\n\n# TD 1\nlibrary(geosphere)\nlibrary(tidygeocoder)\nlibrary(leaflet) \n\n\n# penser à vérifer le chemin de travail et à le corriger si necessaire \ngetwd()\n\n[1] \"/Users/Isabel/Desktop/Cours/R avancé/my_blog/posts/Excercices-TD\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#téléchargement-jeu-de-données-depuis-le-site",
    "href": "posts/Excercices-TD/semaine_1.html#téléchargement-jeu-de-données-depuis-le-site",
    "title": "Semaine 1",
    "section": "2. Téléchargement jeu de données depuis le site",
    "text": "2. Téléchargement jeu de données depuis le site\n\nurl &lt;- \"https://www.data.gouv.fr/fr/datasets/r/3f8ea372-3847-495d-9b93-c4a76d553166\"\ndata_ex &lt;- read.csv(url, sep = \";\")\n\n\nnames(data_ex)\n\n[1] \"geo_point\"                      \"nom\"                           \n[3] \"sites_olympiques_paralympiques\" \"sports\"                        \n\ndim(data_ex)\n\n[1] 31  4\n\nstr(data_ex)\n\n'data.frame':   31 obs. of  4 variables:\n $ geo_point                     : chr  \"48.841319, 2.253076\" \"48.924388, 2.359871\" \"48.751095, 2.0759\" \"48.788046, 2.034987\" ...\n $ nom                           : chr  \"Parc des Princes\" \"Stade de France\" \"Golf national\" \"Vélodrome National de Saint-Quentin-en-Yvelines\" ...\n $ sites_olympiques_paralympiques: chr  \"Site olympique\" \"Site olympique,Site paralympique\" \"Site olympique\" \"Site olympique,Site paralympique\" ...\n $ sports                        : chr  \"Football\" \"Athlétisme,Para athlétisme,Rugby\" \"Golf\" \"Cyclisme sur piste,Para cyclisme sur piste\" ...\n\n\nLe nombre de lignes est de 31 pour 4 colonnes nomées : geo_point, nom, sites_olympiques_paralympiques, sports"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#et-4-combien-y-a-til-de-sites-olympiques-et-paralympiques",
    "href": "posts/Excercices-TD/semaine_1.html#et-4-combien-y-a-til-de-sites-olympiques-et-paralympiques",
    "title": "Semaine 1",
    "section": "3 et 4 Combien y a t’il de sites olympiques et paralympiques ?",
    "text": "3 et 4 Combien y a t’il de sites olympiques et paralympiques ?\n\nhead(data_ex)\n\n            geo_point                                             nom\n1 48.841319, 2.253076                                Parc des Princes\n2 48.924388, 2.359871                                 Stade de France\n3   48.751095, 2.0759                                   Golf national\n4 48.788046, 2.034987 Vélodrome National de Saint-Quentin-en-Yvelines\n5  48.84732, 2.245501                             Stade Roland Garros\n6 48.911184, 2.546395                                Clichy-sous-Bois\n    sites_olympiques_paralympiques                                     sports\n1                   Site olympique                                   Football\n2 Site olympique,Site paralympique           Athlétisme,Para athlétisme,Rugby\n3                   Site olympique                                       Golf\n4 Site olympique,Site paralympique Cyclisme sur piste,Para cyclisme sur piste\n5 Site olympique,Site paralympique                Tennis,Tennis fauteuil,Boxe\n6                Site paralympique                    Para cyclisme sur route\n\ntable(data_ex$sites_olympiques_paralympiques )\n\n\n                                                   Site olympique \n                               2                               10 \nSite olympique,Site paralympique                Site paralympique \n                              16                                3 \n\nsites_olympiques &lt;- 0\nsites_paralympique &lt;- 0\n\nfor (site in data_ex$sites_olympiques_paralympiques) {\n  if( grepl(\"Site olympique\", site)) {\n    sites_olympiques &lt;- sites_olympiques + 1\n  }\n  if(grepl(\"Site paralympique\", site)){\n    sites_paralympique &lt;- sites_paralympique + 1\n  }\n}\n\nprint(paste(\"Il y a au total\", sites_olympiques, \"sites olympiques et\", sites_paralympique, \"sites paralympiques\"))\n\n[1] \"Il y a au total 26 sites olympiques et 19 sites paralympiques\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#quels-sont-les-sites-qui-accueillent-plusieurs-disciplines-sportives",
    "href": "posts/Excercices-TD/semaine_1.html#quels-sont-les-sites-qui-accueillent-plusieurs-disciplines-sportives",
    "title": "Semaine 1",
    "section": "5. Quels sont les sites qui accueillent plusieurs disciplines sportives ?",
    "text": "5. Quels sont les sites qui accueillent plusieurs disciplines sportives ?\n\nsites_multi_sport &lt;- data_ex[sapply(strsplit(data_ex$sports, \",\"), length) &gt;1, ]\nprint(\"Les sites accueillant plusieurs disciplines sportives sont :\")\n\n[1] \"Les sites accueillant plusieurs disciplines sportives sont :\"\n\nprint(sites_multi_sport$nom)\n\n [1] \"Stade de France\"                                \n [2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n [3] \"Stade Roland Garros\"                            \n [4] \"Arena Paris Sud 4 (Porte de Versailles)\"        \n [5] \"Pont d'Iéna\"                                    \n [6] \"Arena Bercy\"                                    \n [7] \"Arena Paris nord\"                               \n [8] \"Arena Paris Sud 6 (Porte de Versailles)\"        \n [9] \"Stade de la Concorde\"                           \n[10] \"Arena Champs de Mars\"                           \n[11] \"La Défense Arena\"                               \n[12] \"Stade nautique\"                                 \n[13] \"Arena Paris Sud 1 (Porte de Versailles)\"        \n[14] \"Stade Tour Eiffel\"                              \n[15] \"Arena La Chapelle\"                              \n[16] \"Centre aquatique\"                               \n[17] \"Château de Versailles\"                          \n[18] \"Grand Palais\"                                   \n[19] \"Invalides\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#quels-sont-les-disciplines-para-olympiques-accueillies-dans-ces-sites-franciliens",
    "href": "posts/Excercices-TD/semaine_1.html#quels-sont-les-disciplines-para-olympiques-accueillies-dans-ces-sites-franciliens",
    "title": "Semaine 1",
    "section": "6. Quels sont les disciplines para-olympiques accueillies dans ces sites franciliens ?",
    "text": "6. Quels sont les disciplines para-olympiques accueillies dans ces sites franciliens ?\n(franciliens = De l’Île-de-France)\n\ndata_paralympique &lt;- data_ex[grepl(\"Site paralympique\", data_ex$sites_olympiques_paralympiques), ]\n\ndisciplines_paralympiques &lt;- unique(unlist(strsplit(data_paralympique$sports, \",\")))\n\nprint(paste(\"Les disciplines para-olympiques accueillies sont:\", paste(disciplines_paralympiques, collapse = \", \")))\n\n[1] \"Les disciplines para-olympiques accueillies sont: Athlétisme, Para athlétisme, Rugby, Cyclisme sur piste, Para cyclisme sur piste, Tennis, Tennis fauteuil, Boxe, Para cyclisme sur route, Tennis de table, Para tennis de table, Basketball, Basket fauteuil, Gymnastique artistique, trampoline, Escrime, Pentathlon moderne, Volley-ball assis, Haltérophilie, Handball, Goalball, Judo, Para judo, Lutte, Rugby fauteuil, Natation, Para natation, Water-polo, Canoë, Para canoë, Aviron, Para aviron, Volleyball, Boccia, Volleyball de plage, Cécifoot, Badminton, Para Badminton, Gymnastique rythmique, Para powerlifting, Sports équestres, Para équitation, Escrime fauteuil, Taekwondo, Para taekwondo, Tir à l'arc, Para tir à l'arc, Cyclisme sur route\"\n\n\nConcernant le code :\nLa fonction strsplit est utilisée pour diviser des chaînes de caractères en sous-composants en fonction d’un séparateur spécifié.\ngrepl Est utile pour filtrer des données ou vérifier la présence de certaines sous-chaînes.\nunlist Transforme la liste en un vecteur unique, concaténant tous les éléments des différentes entrées en un seul vecteur long.\nunique Extrait les éléments uniques de ce vecteur, supprimant les répétitions."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#quels-sites-accueillent-le-plus-de-disciplines-différentes",
    "href": "posts/Excercices-TD/semaine_1.html#quels-sites-accueillent-le-plus-de-disciplines-différentes",
    "title": "Semaine 1",
    "section": "7. Quel(s) site(s) accueille(nt) le plus de disciplines différentes ?",
    "text": "7. Quel(s) site(s) accueille(nt) le plus de disciplines différentes ?\n\nsapply(strsplit(data_ex$sports, \",\"), function(x) length(unique(x)) )\n\n [1] 1 3 1 2 3 1 2 1 2 4 4 3 4 1 4 3 4 2 2 1 4 1 3 0 3 0 1 1 4 4 1\n\nnombre_de_disciplines &lt;- data.frame(site = data_ex$nom, \n                         nombre_disciplines = sapply(strsplit(data_ex$sports, \",\"), function(x) length(unique(x))))\n\nsites_nombre_disciplines &lt;- nombre_de_disciplines[order                                            (-nombre_de_disciplines$nombre_disciplines),]\n\nsites_4_disciplines &lt;- sites_nombre_disciplines[sites_nombre_disciplines$nombre_disciplines&gt;3,]\n\nprint(paste(\"Les sites accueillant les plus de disciplines (4) sont :\", paste(sites_4_disciplines$site, collapse = \",\")))\n\n[1] \"Les sites accueillant les plus de disciplines (4) sont : Arena Bercy,Arena Paris nord,Stade de la Concorde,Arena Champs de Mars,Stade nautique,Arena La Chapelle,Grand Palais,Invalides\""
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#quel-discipline-aura-lieu-sur-le-plus-grand-nombre-de-sites-quels-sont-ces-sites",
    "href": "posts/Excercices-TD/semaine_1.html#quel-discipline-aura-lieu-sur-le-plus-grand-nombre-de-sites-quels-sont-ces-sites",
    "title": "Semaine 1",
    "section": "8. Quel discipline aura lieu sur le plus grand nombre de sites ? Quels sont ces sites ?",
    "text": "8. Quel discipline aura lieu sur le plus grand nombre de sites ? Quels sont ces sites ?\nPour répondre à la question, nous devons extraire les disciplines, les associer à chaque site et ensuite compter le nombre de sites par discipline:\n\nsites_et_disciplines &lt;- data.frame(\n  site = rep(data_ex$nom, sapply(data_ex$sports, function(x) length(strsplit(x, \",\")[[1]]))),\n  discipline = unlist(strsplit(data_ex$sports, \",\"))\n)\n\nnombre_sites_par_discipline &lt;- aggregate(site ~ discipline, sites_et_disciplines, FUN = function(x) length(unique(x)))\n\nAvec cet information, nous pouvons identifier la discipline qui est presente dans le plus grand nombre de sites :\n\ndiscipline_max_sites &lt;- nombre_sites_par_discipline[which.max(nombre_sites_par_discipline$site), ]\ndiscipline_max_sites\n\n  discipline site\n1 Athlétisme    4\n\n\nEt pour finir, nous pouvons voir les sites pour cette discipline :\n\nsubset(sites_et_disciplines, discipline == discipline_max_sites$discipline)\n\n                      site discipline\n2          Stade de France Athlétisme\n14 Hôtel de ville de Paris Athlétisme\n16             Pont d'Iéna Athlétisme\n68               Invalides Athlétisme"
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#a-vol-doiseau-quels-sont-les-sites-les-deux-sites-les-plus-proches",
    "href": "posts/Excercices-TD/semaine_1.html#a-vol-doiseau-quels-sont-les-sites-les-deux-sites-les-plus-proches",
    "title": "Semaine 1",
    "section": "9. A vol d’oiseau, quels sont les sites les deux sites les plus proches ?",
    "text": "9. A vol d’oiseau, quels sont les sites les deux sites les plus proches ?\nNous allons utiliser les coordonnées geographiques presentes dans la colonne geo_point et la fonction distHaversine, qui est une fonction du package geosphere pour calculer des distances sur une sphère entre deux points géolocalisés.\n(Selon la documentation du package geosphere, la fonction distHaversine retournera les résultats en mètres.)\n\nhead(data_ex$geo_point)\n\n[1] \"48.841319, 2.253076\" \"48.924388, 2.359871\" \"48.751095, 2.0759\"  \n[4] \"48.788046, 2.034987\" \"48.84732, 2.245501\"  \"48.911184, 2.546395\"\n\n\nComme nous pouvons le constater, la variable geo_point regroupe les coordonnées de latitude et de longitude. Par conséquent, nous allons les séparer en deux colonnes distinctes et les convertir en valeurs numériques:\n\ncoords &lt;- strsplit(as.character(data_ex$geo_point), \", \")\ndata_ex$latitude &lt;- as.numeric(sapply(coords, `[`, 1))\ndata_ex$longitude &lt;- as.numeric(sapply(coords, `[`, 2))\n\nMaintenant nous pouvons calculer la matrice de distance entre tous les sites\n\ndist_matrix &lt;- distm(data_ex[, c(\"longitude\", \"latitude\")], fun = distHaversine)\n\n# Remplacement de la diagonale par NA pour ignorer la distance de chaque site à lui-même\ndiag(dist_matrix) &lt;- NA\n\nPour identifier les deux sites ayant la distance la plus courte entre eux. Nous allons :\n\n# Trouver la distance la plus courte à l'aide de min\nmin_dist &lt;- min(dist_matrix, na.rm = TRUE)\n\n# Identifier les sites les plus proches, on compare chaque élément de la matrice de distances \nsites_indices &lt;- which(dist_matrix == min_dist, arr.ind = TRUE)\n\nsite1 &lt;- data_ex$nom[sites_indices[1, 1]]  \nsite2 &lt;- data_ex$nom[sites_indices[1, 2]]  \n\ncat(\"Les deux sites les plus proches à vol d'oiseau sont :\", site1, \"et\", site2,  \"avec une distance de\", round(min_dist), \"mètres.\\n\")\n\nLes deux sites les plus proches à vol d'oiseau sont : Stade BMX de Saint-Quentin-en-Yvelines et Vélodrome National de Saint-Quentin-en-Yvelines avec une distance de 89 mètres."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#quels-sont-les-deux-sites-les-plus-éloignés",
    "href": "posts/Excercices-TD/semaine_1.html#quels-sont-les-deux-sites-les-plus-éloignés",
    "title": "Semaine 1",
    "section": "10. Quels sont les deux sites les plus éloignés ?",
    "text": "10. Quels sont les deux sites les plus éloignés ?\nCette fois-ci, nous allons déterminer la distance maximale en utilisant la fonction max.\n\nmax_dist &lt;- max(dist_matrix, na.rm = TRUE)\n\nEt maintenant, comme nous l’avons fait précédemment, nous pouvons identifier les indices correspondant à la distance maximale afin de déterminer les deux sites concernés.\n\nsites_indices_max &lt;- which(dist_matrix == max_dist, arr.ind = TRUE)\nsite1_max &lt;- data_ex$nom[sites_indices_max[1, 1]]  \nsite2_max &lt;- data_ex$nom[sites_indices_max[1, 2]] \ncat(\"Les deux sites les plus éloignés à vol d'oiseau sont :\", site1_max, \"et\", site2_max,  \"avec une distance de\", round(max_dist), \"mètres.\\n\")\n\nLes deux sites les plus éloignés à vol d'oiseau sont : Colline d'Elancourt et Stade nautique avec une distance de 49689 mètres."
  },
  {
    "objectID": "posts/Excercices-TD/semaine_1.html#où-se-situe-le-barycentre-de-lensemble-des-sites-olympiques",
    "href": "posts/Excercices-TD/semaine_1.html#où-se-situe-le-barycentre-de-lensemble-des-sites-olympiques",
    "title": "Semaine 1",
    "section": "11. Où se situe le barycentre de l’ensemble des sites olympiques",
    "text": "11. Où se situe le barycentre de l’ensemble des sites olympiques\nNous allons calculer les moyennes des latitudes et des longitudes pour trouver le barycentre.\n\nbarycentre_lat &lt;- mean(data_ex$latitude)\nbarycentre_lon &lt;- mean(data_ex$longitude)\ncat(\"L'appartement situé au barycentre de l'ensemble des sites olympiques se trouve à la latitude :\", barycentre_lat, \"et à la longitude :\", barycentre_lon, \"\\n\")\n\nL'appartement situé au barycentre de l'ensemble des sites olympiques se trouve à la latitude : 48.86684 et à la longitude : 2.29757 \n\n\nMaintenant, grâce à la fonction reverse_geocode, nous pourrons identifier l’adresse. Il est important de noter que reverse_geocode nécessite un argument de type .tbl (par exemple, un dataframe) pour fonctionner correctement. Nous enregistrerons donc les coordonnées dans un dataframe:\n\nbarycentre_df &lt;- data.frame(\n  lat = barycentre_lat,\n  long = barycentre_lon\n)\n\nbarycentre_adresse &lt;- reverse_geocode(\n  .tbl = barycentre_df, \n  lat = lat, \n  long = long,\n  method = \"osm\" # Utilise OpenStreetMap pour le géocodage inverse\n)\n\nprint(barycentre_adresse)\n\n# A tibble: 1 × 3\n    lat  long address                                                           \n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                                                             \n1  48.9  2.30 23, Avenue Pierre 1er de Serbie, Quartier de Chaillot, Paris 16e …\n\n\n\n\n\n\n\n\nBonus - carte\n\n\n\nAvec la question 11, nous arrivons à la fin des exercices de la semaine 1. Avant de continuer avec les exercices de la semaine 2, nous pouvons créer un graphique qui utilise le dataframe barycentre_adresse et la fonction leaflet pour visualiser sur une carte l’adresse que nous avons obtenuetre_adresse et la fonction leaflet pour visualiser dans une carte l’adresse que nous avons obtenue.\n\n\n\nleaflet(data = barycentre_adresse) |&gt;\n  addTiles() |&gt;\n  addMarkers(~long, ~lat, popup = ~address)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science avec Isabel",
    "section": "",
    "text": "Bienvenue sur mon blog ! Ici, je partage mes projets, sur tout ce qui touche à l’analyse de données, la programmation en R et Python, et bien plus. Restez à jour en explorant mes derniers articles ci-dessous.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSemaine 3\n\n\n\n\n\n\nTD\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nIsabel\n\n\n\n\n\n\n\n\n\n\n\n\nSemaine 2\n\n\n\n\n\n\nTD\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nIsabel\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\n\n\nTD\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nIsabel\n\n\n\n\n\n\n\n\n\n\n\n\nSemaine 1\n\n\n\n\n\n\nTD\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nIsabel\n\n\n\n\n\n\n\n\n\n\n\n\nPackage olympicsWeather\n\n\n\n\n\n\nPackage\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nIsabel\n\n\n\n\n\n\n\n\n\n\n\n\nBienvenue sur mon Blog\n\n\n\n\n\n\nBienvenue\n\n\n\n\n\n\n\n\n\nFeb 22, 2024\n\n\nIsabel PALACIO\n\n\n\n\n\n\nNo matching items"
  }
]