{
  "hash": "af5df20fc5ce16b45ec5487ab7d16156",
  "result": {
    "markdown": "---\ntitle: \"Semaine 2\"\nformat: \n  html:\n    toc: true\n    toc_float: \n      collapsed: false\n      smooth_scroll: true\neditor: visual\ndate: \"2024-02-25\"\nimage: \"jo.png\"\ncategories: [TD]\nauthor: \"Isabel\"\n---\n\n\n# Librairies\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TD 2\nlibrary(rvest)\nlibrary(purrr)\nlibrary(stringr)\n```\n:::\n\n\n\n\n# Semaine 2 Exercices\n\n## 1 . Lancer la commande suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_tables <-\n  session(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |>\n  html_elements(\".wikitable\") |>\n  html_table()\n\n\nhead(list_tables, n= 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n# A tibble: 31 × 11\n   Discipline   Discipline   Années `Nombre de` `Nombre de` `médailles décernés`\n   <chr>        <chr>        <chr>  <chr>       <chr>       <chr>               \n 1 \"Discipline\" Discipline   Années Éditions    Épreuves(e… Or                  \n 2 \"\"           Athlétisme   Depui… 29          48          1028                \n 3 \"\"           Aviron       Depui… 28          14          269                 \n 4 \"\"           Badminton    Depui… 8           5           39                  \n 5 \"\"           Basket-ball  Depui… 20          4           32                  \n 6 \"\"           Boxe         1904,… 26          13          266                 \n 7 \"\"           Canoë-kayak  Depui… 20          16          242                 \n 8 \"\"           Cyclisme(ho… Depui… 29          22          263                 \n 9 \"\"           Équitation   1900,… 26          6           151                 \n10 \"\"           Escrime      Depui… 29          12          223                 \n# ℹ 21 more rows\n# ℹ 5 more variables: `médailles décernés` <chr>, `médailles décernés` <chr>,\n#   `médailles décernés` <chr>,\n#   `Athlète(s) avec le plus de médailles (Or-Argent-Bronze)` <chr>,\n#   `Athlète(s) avec le plus de médailles d'or` <chr>\n```\n:::\n:::\n\n\n## 2. Que s’est-il passé ? Que contient l’objet list_tables ?\n\nLa commande récupère les informations de Wikipedia (image ci-dessous), qui contient une liste de tibbles, chacun représentant un tableau qui contient les informations sur les médaillés olympiques.\n\n![](wiki.png)\n\nNous allons tout d’abord nous intéresser à la première table, les jeux olympiques d'été.\n\nCréer un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_medailles_sport_ete <-  list_tables[[1]]\n```\n:::\n\n\nLa table n’est pas bien formatée.\n\nJe supprime la première colonne, la première ligne et je modifie les noms de colonnes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_medailles_sport_ete <- data_medailles_sport_ete[-1, -1]\n\ncolnames(data_medailles_sport_ete) <- c(\"Discipline\", \"Annees\", \"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \"Athletes_or\")\n\nstr(data_medailles_sport_ete)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [30 × 10] (S3: tbl_df/tbl/data.frame)\n $ Discipline        : chr [1:30] \"Athlétisme\" \"Aviron\" \"Badminton\" \"Basket-ball\" ...\n $ Annees            : chr [1:30] \"Depuis 1896\" \"Depuis 1900\" \"Depuis 1992\" \"Depuis 1936\" ...\n $ Editions          : chr [1:30] \"29\" \"28\" \"8\" \"20\" ...\n $ Epreuves_2020     : chr [1:30] \"48\" \"14\" \"5\" \"4\" ...\n $ Or                : chr [1:30] \"1028\" \"269\" \"39\" \"32\" ...\n $ Argent            : chr [1:30] \"1030\" \"268\" \"39\" \"32\" ...\n $ Bronze            : chr [1:30] \"1027\" \"273\" \"43\" \"32\" ...\n $ Total             : chr [1:30] \"3085\" \"810\" \"121\" \"96\" ...\n $ Athletes_medailles: chr [1:30] \"Paavo Nurmi (FIN) (9-3-0)\" \"Elisabeta Lipă (ROU) (5-2-1)\" \"Gao Ling (CHN) (2-1-1)\" \"Teresa Edwards (USA) (4-0-1)\" ...\n $ Athletes_or       : chr [1:30] \"Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)\" \"Elisabeta Lipă (ROU) (5-2-1) Georgeta Damian (ROU) (5-0-1) Steven Redgrave (GBR) (5-0-1)\" \"Gao Ling (CHN) (2-1-1) Kim Dong-moon (KOR) (2-0-1) Zhang Nan (CHN) (2-0-1) Ge Fei (CHN) (2-0-0) Gu Jun (CHN) (2\"| __truncated__ \"Teresa Edwards (USA) (4-0-1) Sue Bird (USA) (4-0-0) Tamika Catchings (USA) (4-0-0) Lisa Leslie (USA) (4-0-0) Di\"| __truncated__ ...\n```\n:::\n:::\n\n\nLes colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total seront converties en colonnes d’entiers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_medailles_sport_ete[c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")] <- lapply(data_medailles_sport_ete[c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")], as.integer)\n\nstr(data_medailles_sport_ete)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [30 × 10] (S3: tbl_df/tbl/data.frame)\n $ Discipline        : chr [1:30] \"Athlétisme\" \"Aviron\" \"Badminton\" \"Basket-ball\" ...\n $ Annees            : chr [1:30] \"Depuis 1896\" \"Depuis 1900\" \"Depuis 1992\" \"Depuis 1936\" ...\n $ Editions          : int [1:30] 29 28 8 20 26 20 29 26 29 27 ...\n $ Epreuves_2020     : int [1:30] 48 14 5 4 13 16 22 6 12 2 ...\n $ Or                : int [1:30] 1028 269 39 32 266 242 263 151 223 34 ...\n $ Argent            : int [1:30] 1030 268 39 32 266 241 261 149 223 34 ...\n $ Bronze            : int [1:30] 1027 273 43 32 472 243 260 148 221 35 ...\n $ Total             : int [1:30] 3085 810 121 96 1004 726 784 448 667 103 ...\n $ Athletes_medailles: chr [1:30] \"Paavo Nurmi (FIN) (9-3-0)\" \"Elisabeta Lipă (ROU) (5-2-1)\" \"Gao Ling (CHN) (2-1-1)\" \"Teresa Edwards (USA) (4-0-1)\" ...\n $ Athletes_or       : chr [1:30] \"Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)\" \"Elisabeta Lipă (ROU) (5-2-1) Georgeta Damian (ROU) (5-0-1) Steven Redgrave (GBR) (5-0-1)\" \"Gao Ling (CHN) (2-1-1) Kim Dong-moon (KOR) (2-0-1) Zhang Nan (CHN) (2-0-1) Ge Fei (CHN) (2-0-0) Gu Jun (CHN) (2\"| __truncated__ \"Teresa Edwards (USA) (4-0-1) Sue Bird (USA) (4-0-0) Tamika Catchings (USA) (4-0-0) Lisa Leslie (USA) (4-0-0) Di\"| __truncated__ ...\n```\n:::\n:::\n\n\n## 3. Quelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?\n\nà l'aide de : **order**, nous pouvons trier les indices des lignes du dataframe en fonction de la colonne **`Total`**, en ordre décroissant (**`decreasing = TRUE`** signifie que les valeurs les plus élevées viennent en premier).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop3_disciplines <- data_medailles_sport_ete[order(data_medailles_sport_ete$Total, decreasing = TRUE), ][1:3,]\n\ncat(\"Les 3 disciplines avec le plus de médailles sont :\", paste(top3_disciplines$Discipline, collapse = \", \"), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLes 3 disciplines avec le plus de médailles sont : Athlétisme, Natation(hommes, femmes), Lutte \n```\n:::\n:::\n\n\n## 4. Quelles sont les disciplines avec le moins d’épreuves en 2020 ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndisc_moins_epreuves_2020 <- data_medailles_sport_ete[(data_medailles_sport_ete$Epreuves_2020 == (min(data_medailles_sport_ete$Epreuves_2020))),] \n# utilisation du min et == pour trouver les epreuves avec le moins d'épreuves\n\ncat(\"Les disciplines avec le moins d'éprevues en 2020 sont:\", paste(disc_moins_epreuves_2020$Discipline, collapse = \",\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLes disciplines avec le moins d'éprevues en 2020 sont: Football,Golf,Handball,Hockey sur gazon,Natation synchronisée,Pentathlon moderne,Volley-ball,Water polo\n```\n:::\n:::\n\n\n## 5. Création de fonction calcul_nb_editions\n\nLa colonne Editions nous renseigne sur le nombre total d’apparence des disciplines aux JO d’été. Nous souhaitons vérifier ce calcul en implémentant notre propre fonction calcul_nb_editions_int. Dans un premier temps, la fonction calcul_nb_editions prendra en entrée un paramètre depuis, de type entier, qui représente depuis quelle année la discipline est au programme.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Premier partie, fonction calcul de nombre d'editions \ncalcul_nb_editions <- function(depuis){\n  # Calcul de l'année en cours pour connaitre le nombre d'année au total\n  annee_actuelle <- as.integer(format(Sys.Date(), \"%Y\"))\n  annees_editions <- seq(depuis, annee_actuelle, 4)\n  nb_edtions <- length(annees_editions)\n  return(nb_edtions)\n}\ncalcul_nb_editions(1896)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33\n```\n:::\n\n```{.r .cell-code}\n# Sys.Date() est une fonction en R qui retourne la date courante.\n# Formate cette date pour extraire l'année en cours sous forme de chaîne de caractères avec format(…, \"%Y\") et as.integer convertit cette chaîne en un entier avec as.integer()\n```\n:::\n\n\nLa deuxieme partie, consiste à verifier la colonne Editions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(data_medailles_sport_ete$Annees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:30] \"Depuis 1896\" \"Depuis 1900\" \"Depuis 1992\" \"Depuis 1936\" ...\n```\n:::\n:::\n\n\nPour vérifier la colonne Éditions, il est nécessaire de récupérer les informations relatives aux années de participation aux Jeux Olympiques, que ce soit par année individuelle, par plage d'années, ou en continu depuis une année donnée. La colonne des années est définie comme une chaîne de caractères; Il faut donc créer une fonction qui extraira toutes les années et les comptabilisera.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcul_nb_editions_str <- function(annee_texte){\n  annee_actuelle <- as.integer(format(Sys.Date(), \"%Y\"))\n  annees <- unlist(str_extract_all(annee_texte, \"\\\\b\\\\d{4}\\\\b\")) \n  # Extraire toutes les années individuelles\n   depuis_annees <- as.integer(unlist(str_extract_all(annee_texte, regex(\"(?<=depuis )\\\\d{4}\", ignore_case = TRUE)))) \n   # Extraire les années de départ pour \"depuis / Depuis \"\n  \n   # Traiter les plages d'années\n  plages <- str_extract_all(annee_texte, \"\\\\d{4}–\\\\d{4}\") # Extraire les plages d'années\n  plages <- unlist(plages)\n  for (plage in plages) {\n    annees_debut_fin <- as.integer(unlist(str_extract_all(plage, \"\\\\d{4}\")))\n    annees <- c(annees, seq(annees_debut_fin[1], annees_debut_fin[2], by = 4))\n  }\n  # Ajouter les éditions depuis les années spécifiques jusqu'à l'année actuelle\n  for (depuis_annee in depuis_annees) {\n    annees_depuis <- seq(depuis_annee, annee_actuelle, by = 4)\n    annees <- c(annees, annees_depuis)\n  }\n   # Calculer le nombre d'éditions uniques\n  nb_editions <- length(unique(as.integer(annees)))\n  \n  return(nb_editions)\n}\n\n\ncomparatif <- data.frame(\n  Edtions = data_medailles_sport_ete$Editions, \n  Editions_a_2024 = sapply(data_medailles_sport_ete$Annees, calcul_nb_editions_str))\nhead(comparatif)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Edtions Editions_a_2024\n1      29              33\n2      28              32\n3       8               9\n4      20              23\n5      26              29\n6      20              23\n```\n:::\n:::\n\n\nPlusieurs différences sont présentes dans le comparatif, ce qui peut être expliqué par le fait que notre méthode de calcul n'inclut pas les annulations des Jeux Olympiques. Par exemple, les jeux de 1916, 1940 et 1944 n'ont pas eu lieu en raison des deux guerres mondiales, réduisant ainsi le nombre d'éditions effectivement réalisées. De plus, la dernière modification de l'article Wikipedia datant d'août 2023 pourrait indiquer que l'article a intégré les informations les plus récentes disponibles à cette période, y compris potentiellement les Jeux Olympiques de Tokyo 2020 qui ont été reportés à 2021 à cause de la pandémie de COVID-19.\n\n::: callout-tip\n## regex(..., ignore_case = TRUE)\n\nEst utilisé pour créer une expression régulière avec l'option ignore_case = TRUE, rendant la recherche insensible à la casse.\n:::\n\n## 6. Fonction calcul_nb_editions_str\n\nDans certains cas, les disciplines ont été au programme de façon discontinue. Proposez une nouvelle fonction calcul_nb_editions_str qui prendra cette fois-ci en entrée des chaînes de caractères. Par exemple, l’appel suivant: calcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\n::: callout-note\nLa fonction `calcul_nb_editions_str` a déjà était conçue pour extraire des années individuelles, traiter des plages d'années, et compter les éditions depuis une certaine année jusqu'à l'année actuelle dans la question 5.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 29\n```\n:::\n:::\n\n\nCepandant si les années sont presentés comme une liste ou un vecteur (incluant des valeurs individuelles ), il faut une function tel que :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcul_nb_editions.integer <- function(annees_participation) {\n  nb_participations <- length(unique(annees_participation))\n  return(nb_participations)\n}\n\ncalcul_nb_editions.integer(1900)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## 7. Fonctions calcul_nb_editions.integer et ‘calcul_nb_editions.character\n\nDéfinissez une fonction générique calcul_nb_editions et deux implémentations calcul_nb_editions.integer et ‘calcul_nb_editions.character. Quels résultats donnent les appels : calcul_nb_editions(2000) calcul_nb_editions(\"1904–1924, depuis 1948\")\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Définition de la fonction génerique\ncalcul_nb_editions <- function(x) {\n  UseMethod(\"calcul_nb_editions\")\n}\n```\n:::\n\n\nPour les entiers, nous utilisons la fonction calcul_nb_additions.integer, mais nous la compléterons avec une fonction calcul_nb_editions.numeric car en R, les nombres sans point décimal sont souvent traités comme des numériques (numeric), même s'ils représentent des entiers. Cela signifie que si l'on teste un nombre tel que 2000 avec calcul_nb_editions, R cherchera une méthode applicable aux classes numeric ou double, et non integer\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# méthode existante pour les entiers\ncalcul_nb_editions.integer <- function(x) {\n  nb_participations <- length(unique(x))\n  return(nb_participations)\n}\n\n#  méthode pour les numériques \ncalcul_nb_editions.numeric <- function(x) {\n  # Vérifier si x est entier\n  if (x == floor(x)) {\n    # Convertir x en entier et appeler la méthode pour 'integer'\n    return(calcul_nb_editions.integer(as.integer(x)))\n  } else {\n    stop(\"La méthode n'est définie que pour les entiers\")\n  }\n}\n```\n:::\n\n\nPour les Chaînes de Caractères\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcul_nb_editions.character <- function(x) {\n  annee_actuelle <- as.integer(format(Sys.Date(), \"%Y\"))\n  annees <- unlist(str_extract_all(x, \"\\\\b\\\\d{4}\\\\b\")) # Extraire toutes les années individuelles\n  depuis_annees <- as.integer(unlist(str_extract_all(x, regex(\"(?<=depuis )\\\\d{4}\", ignore_case = TRUE)))) # Extraire les années de départ pour \"depuis / Depuis\"\n  \n  # plages d'années\n  plages <- str_extract_all(x, \"\\\\d{4}–\\\\d{4}\") # Extraire les plages d'années\n  plages <- unlist(plages)\n  for (plage in plages) {\n    annees_debut_fin <- as.integer(unlist(str_extract_all(plage, \"\\\\d{4}\")))\n    annees <- c(annees, seq(annees_debut_fin[1], annees_debut_fin[2], by = 4))\n  }\n  # Ajout les éditions depuis les années spécifiques jusqu'à l'année actuelle\n  for (depuis_annee in depuis_annees) {\n    annees_depuis <- seq(depuis_annee, annee_actuelle, by = 4)\n    annees <- c(annees, annees_depuis)\n  }\n  # Calcule le nombre d'éditions uniques\n  nb_editions <- length(unique(as.integer(annees)))\n  \n  return(nb_editions)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcul_nb_editions(2000)\ncalcul_nb_editions(\"1904–1924, depuis 1948\")\n```\n:::\n\n\n## 8. Fonction \\< calcul_medailles_individuelles\\>\n\nEn Athlétisme, le Finlandais Paavo Nurmi détient le record de médailles avec 12 médailles obtenues lors des JO d’hiver.\n\nImplémentez une fonction \\< calcul_medailles_individuelles\\> qui détermine le nombre de médaille maximal a été obtenu par un athlète lors d’olympiades. Note : s’il y a plusieurs athlètes à égalité, alors la cellule comporte plusieurs éléments, et une manipulation de la chaîne de caractères est nécessaire.\n\n-   Les jeux olympiques d'hiver se trouvent dans la list_tables, 2eme\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_medailles_sport_hiver <- list_tables[[2]]\ndata_medailles_sport_hiver <- data_medailles_sport_hiver[-1,-1]\ndata_medailles_sport_hiver$Discipline\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Biathlon\"                            \n [2] \"Bobsleigh\"                           \n [3] \"Combiné nordique\"                    \n [4] \"Curling\"                             \n [5] \"Hockey sur glace\"                    \n [6] \"Luge\"                                \n [7] \"Patinage artistique\"                 \n [8] \"Patinage de vitesse\"                 \n [9] \"Patinage de vitesse sur piste courte\"\n[10] \"Saut à ski\"                          \n[11] \"Skeleton\"                            \n[12] \"Ski acrobatique\"                     \n[13] \"Ski alpin\"                           \n[14] \"Ski de fond\"                         \n[15] \"Snowboard\"                           \n```\n:::\n:::\n\n\n::: callout-warning\nLa discipline Athétisme fait partie des jeux olympiques d'été et non d'hiver, alors je retourne au df été\n:::\n\nLa colonne N° 9 designe les **Athlète(s) avec le plus de médailles (Or-Argent-Bronze)** de la maniere suivante\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(data_medailles_sport_ete$Athletes_medailles)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Paavo Nurmi (FIN) (9-3-0)\"                                                                                                                                                                                                                                                                              \n[2] \"Elisabeta Lipă (ROU) (5-2-1)\"                                                                                                                                                                                                                                                                           \n[3] \"Gao Ling (CHN) (2-1-1)\"                                                                                                                                                                                                                                                                                 \n[4] \"Teresa Edwards (USA) (4-0-1)\"                                                                                                                                                                                                                                                                           \n[5] \"László Papp (HUN) (3-0-0) Félix Savón (CUB) (3-0-0) Teófilo Stevenson (CUB) (3-0-0) Roniel Iglesias (CUB) (2-0-1) Boris Lagutin (URS) (2-0-1) Oleg Saitov (RUS) (2-0-1) Zou Shiming (CHN) (2-0-1) Roberto Cammarelle (ITA) (1-1-1) Zbigniew Pietrzykowski (POL) (0-1-2) Arnold Vanderlyde (NED) (0-0-3)\"\n[6] \"Birgit Fischer (GER) (8-4-0)\"                                                                                                                                                                                                                                                                           \n```\n:::\n:::\n\n\nLa fonction **`calcul_medailles_individuelles`** analyse une chaîne de caractères listant des athlètes avec leurs médailles. Nous créons un dataframe pour recueillir les noms des athlètes et leur total de médailles à partir d'une chaîne de caractères. En utilisant des expressions régulières, nous séparons d'abord chaque athlète et ses médailles. Nous nettoyons ensuite ces données en retirant les parenthèses et en isolant le nom de l'athlète du détail de ses médailles (or, argent, bronze). Après avoir converti ces informations en nombres, nous calculons le total des médailles pour chaque athlète. Ces informations, comprenant le nom de l'athlète et son total de médailles, sont ensuite ajoutées au dataframe. Finalement, ce dataframe, qui synthétise le nom des athlètes et leur performance en termes de médailles, nous est retourné.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcul_medailles_individuelles <- function(athletes_medailles) {\n  # initialiser un dataframe pour stocker les résultats\n  resultats_df <- data.frame(Athlete = character(), TotalMedailles = integer(), stringsAsFactors = FALSE)\n  \n  # séparation des athlètes en utilisant une regex plus robuste\n  athletes_details <- strsplit(athletes_medailles, \"\\\\)\\\\s*(?=[A-Z])\", perl = TRUE)[[1]]\n  \n  for (detail in athletes_details) {\n    detail <- gsub(\"[()]\", \"\", detail) # Nettoyer la chaîne\n    name_medals_parts <- strsplit(detail, \"\\\\s(?=\\\\d+-\\\\d+-\\\\d+)\", perl = TRUE)[[1]] # Séparer nom des médailles\n    \n    if (length(name_medals_parts) < 2) next # Passer si le format n'est pas correct\n    \n    athlete_name <- name_medals_parts[1]\n    medals_info <- strsplit(name_medals_parts[2], \"-\")[[1]]\n    total_medals <- sum(as.integer(medals_info))\n    \n    resultats_df <- rbind(resultats_df, data.frame(Athlete = athlete_name, TotalMedailles = total_medals, stringsAsFactors = FALSE))\n  }\n  \n  return(resultats_df)\n}\n```\n:::\n\n\n::: callout-tip\n### **Pourquoi utiliser `perl = TRUE` ?**\n\n**Fonctionnalités Avancées** : Le moteur Perl offre des fonctionnalités d'expressions régulières plus avancées, telles que les assertions positives et négatives en amont (**`?=`** et **`?!`**), les assertions de mots limites (**`\\b`**), et d'autres constructions complexes qui ne sont pas toujours supportées ou qui peuvent avoir un comportement différent dans le moteur d'expressions régulières de base de R.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# exemple de la fonction pour la ligne 29\ndata_medailles_sport_ete$Athletes_medailles[29]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ana Fernández (CUB) (3-0-1) Kerri Walsh (USA) (3-0-1) Inna Ryskal (URS) (2-2-0) Sérgio Dutra Santos (BRA) (2-2-0) Sergey Tetyukhin (RUS) (1-1-2)\"\n```\n:::\n\n```{.r .cell-code}\ncalcul_medailles_individuelles(data_medailles_sport_ete$Athletes_medailles[29])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  Athlete TotalMedailles\n1       Ana Fernández CUB              4\n2         Kerri Walsh USA              4\n3         Inna Ryskal URS              4\n4 Sérgio Dutra Santos BRA              4\n5    Sergey Tetyukhin RUS              4\n```\n:::\n:::\n\n\n## 9. Quel est le top 3 des athlètes ?\n\nVous utiliserez la fonction lapply pour appliquer la fonction calcul_medailles_individuelles à chaque élément de la colonne Athletes_medailles\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# appliquer la fonction à chaque élément de la colonne Athletes_medailles\nliste_df <- lapply(data_medailles_sport_ete$Athletes_medailles, calcul_medailles_individuelles)\n\n# créer un seul dataframe\ndf_athletes_medailles <- do.call(rbind, liste_df)\n\n# trier le dataframe combiné par TotalMedailles en ordre décroissant et afficher les 3 premiers \ntop_3_athletes <- head(df_athletes_medailles[order(-df_athletes_medailles$TotalMedailles),], 3)\n\nprint(\"Le top 3 des athlètes et leur nombre de médailles sont :\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Le top 3 des athlètes et leur nombre de médailles sont :\"\n```\n:::\n\n```{.r .cell-code}\ntop_3_athletes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   Athlete TotalMedailles\n38      Michael Phelps USA             28\n23    Larissa Latynina URS             18\n18 Edoardo Mangiarotti ITA             13\n```\n:::\n:::\n\n\n## 10. Quels sont les 3 nationalités les plus représentées, pour toutes les épreuves, au classement du nombre de médailles d’or individuelles reccueillies ?\n\n• Pour ce faire, vous implémenterez une fonction extraire_nationalite_athlete qui à partir d’une chaine de charactère extraira le nombre d’athlète et leur nationalité. Par exemple, la chaine de caractère “Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)” donnera en sortie c(\"FIN\" = 1, \"USA\" = 1)\n\n• Vous utilisez la fonction lapply pour appliquer la fonction à toute la colonne 8. En Athlétisme, le Finlandais Paavo Nurmi détient le record de médailles avec 12 médailles obtenues lors des JO d’hiver\n\n• Vous agrégerez les résultats de manière à sommer toutes les lignes et à obtenir les 3 nations les plus représentées, et leur effectif.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextraire_nationalite_athlete <- function(texte) {\n  # Extraire les morceaux contenant la nationalité et les médailles d'or\n  matches <- gregexpr(\"\\\\([A-Z]{3}\\\\) \\\\((\\\\d+)-\", texte)\n  nationalites_et_or <- regmatches(texte, matches)\n  \n  # Initialiser un vecteur pour les nationalités\n  nationalites <- vector(\"list\", length(nationalites_et_or[[1]]))\n  \n  for(i in seq_along(nationalites_et_or[[1]])) {\n    match <- nationalites_et_or[[1]][i]\n    nationalite <- substr(match, 2, 4) # Extraire la nationalité\n    or <- as.numeric(substr(match, 8, nchar(match)-1)) # Extraire le nombre de médailles d'or\n    \n    if(or > 0) { # compter seulement si au moins une médaille d'or a été gagnée\n      if(!is.null(nationalites[[nationalite]])) {\n        nationalites[[nationalite]] <- nationalites[[nationalite]] + 1\n      } else {\n        nationalites[[nationalite]] <- 1\n      }\n    }\n  }\n  \n  return(unlist(nationalites))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultats_nationalites <- lapply(data_medailles_sport_ete$Athletes_medailles, extraire_nationalite_athlete)\n\nnationalites_agg <- Reduce(`+`, resultats_nationalites)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in f(init, x[[i]]): longer object length is not a multiple of shorter\nobject length\n\nWarning in f(init, x[[i]]): longer object length is not a multiple of shorter\nobject length\n```\n:::\n\n```{.r .cell-code}\n# les 3 nationalités les plus représentées\ntop_3_nationalites <- sort(nationalites_agg, decreasing = TRUE)[1:3]\n\nprint(\"Les 3 nationalités les plus représentées en médailles d'or sont :\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Les 3 nationalités les plus représentées en médailles d'or sont :\"\n```\n:::\n\n```{.r .cell-code}\nprint(top_3_nationalites)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCUB HUN URS \n 35  33  33 \n```\n:::\n:::\n\n\nOn commence par extraire les nationalités et le nombre d'athlètes ayant remporté au moins une médaille d'or de chaque chaîne de caractères fournie. Ensuite, on utilise **`lapply`** pour appliquer cette opération à chaque élément de la colonne **`Athletes_medailles`** et **`Reduce`** pour sommer les résultats et obtenir un compte total par nationalité.\n\n## 11. Utilisation du package purr\n\nIntéressez-vous désormais au deuxième tableau contenu dans list_tables, faisant référence aux JO d’hiver. Appliquez les fonctions calcul_medailles_individuelles et extraire_nationalite_athlete aux deux dernières colonnes, à la manière des questions 9 et 10. Cette fois-ci, vous utiliserez la fonction appropriée du package purrr en lieu et place de lapply. Quelles sont les résultats ? Quelle différence voyez-vous entre lapply et les fonctions de purrr ?\n\nNous avions precedement récuperé le deuximem tableau, faisant référence aux JO d'hiver, dans un tibble appélé data_medailles_sport_hiver\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(data_medailles_sport_hiver[9])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  `Athlète(s) avec le plus de médailles (Or-Argent-Bronze)`                     \n  <chr>                                                                         \n1 \"Ole Einar Bjørndalen (NOR) (8-4-1)\"                                          \n2 \"Bogdan Musiol (RDA) (1-5-1)\"                                                 \n3 \"Felix Gottwald (AUT) (3-1-3)\"                                                \n4 \"Anna Le Moine (SWE) (2-0-0) Cathrine Lindahl (SWE) (2-0-0) Eva Lund (SWE) (2…\n5 \"Jayna Hefford (CAN) (4-1-0) Hayley Wickenheiser (CAN) (4-1-0)\"               \n6 \"Armin Zöggeler (ITA) (2-1-3)\"                                                \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# appliquer la fonction à chaque élément de la colonne 9 en utilisant map_df pour retourner un dataframe\ndf_athletes_medailles <- map_df(data_medailles_sport_hiver[[9]], calcul_medailles_individuelles)\n\n# Trier le dataframe combiné par TotalMedailles en ordre décroissant et sélectionner les 3 premiers athlètes\ntop_3_athletes <- head(df_athletes_medailles[order(-df_athletes_medailles$TotalMedailles),], 3)\n\n# Affichage du top 3 des athlètes et leur nombre de médailles\nprint(\"Le top 3 des athlètes et leur nombre de médailles sont :\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Le top 3 des athlètes et leur nombre de médailles sont :\"\n```\n:::\n\n```{.r .cell-code}\nprint(top_3_athletes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                    Athlete TotalMedailles\n29        Marit Bjørgen NOR             15\n1  Ole Einar Bjørndalen NOR             13\n18           Ireen Wüst NED             11\n```\n:::\n:::\n\n\nLa fonction map_df de purrr est utilisée pour appliquer calcul_medailles_individuelles à chaque élément de la colonne sélectionnée et retourner directement un dataframe. Contrairement à lapply, qui retourne une liste, map_df simplifie le processus en combinant directement les résultats dans un dataframe, éliminant ainsi le besoin d'utiliser do.call(rbind, ...) pour fusionner les résultats.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}